# Project Charter: Pluto

## Vision

> **Pluto is the "nginx for AI agents"** — a minimal, fast, self-hostable runtime that runs agents defined in a **transparent, portable format**, exposed through a standard API.

Pluto treats agents as durable artifacts: files you own that should outlast the runtime.
- **Transparent agent format** (human-readable, inspectable, versionable)
- **Stateless by default** (no hidden server-side state)
- **File-based state** when present (specs, memories, logs, config) — if Pluto disappears, take these and host elsewhere

## Problem Statement

Developers building AI-powered applications want a way to run agents where the **agent and its state are durable, portable artifacts** (not trapped inside a runtime):
1. A transparent, versionable agent definition
2. A stateless-by-default runtime with file-based, exportable state (specs, memories, logs, config)
3. A standard API, with provider-agnostic LLM integration

Current options require either:
- Buying into a heavy framework
- Building everything from scratch
- Using proprietary, cloud-only services

The ecosystem is fragmented, so Pluto proposes a practical standard today and will adopt any widely accepted, open agent definition standard once it emerges.

## Goals

1. **Lightweight & self-hostable** — Single binary, <10MB, starts in milliseconds
2. **Standards-compliant** — Agent Protocol API, Open Agent Spec format, MCP for tools (and follow widely adopted open standards as they emerge)
3. **LLM-agnostic** — OpenRouter, OpenAI, Anthropic, Ollama, any OpenAI-compatible API
4. **Durable, file-first artifacts** — Agent specs + state are files you can copy, back up, and version
5. **Pluggable state & memory** — Defaults are filesystem; optional external backends (e.g. Postgres, Redis, S3)
6. **Developer-friendly** — Clear docs, easy to contribute, MIT licensed

## Non-Goals (v1.0)

- Web UI or visual builder
- Multi-agent orchestration
- Built-in RAG/vector search
- Workflow/DAG execution engine
- User authentication
- Requiring external infrastructure for basic usage (DB, queues, etc.)
- Proprietary agent formats or hidden state that can't be exported

## Design Principles

### 1. Lean Core, Extensible Edges

- Prefer a lean core with a simple agent / execution loop
- Push complexity to configuration and pluggable components
- Add knobs only when real use cases demand them

### 2. Durable Artifacts, Minimal State

- Keep the core process stateless and restart-safe
- Default to file-based state; when state needs a service, make it explicit and exportable
- Support optional external backends for advanced deployments

### 3. Observability-first

- Make behavior inspectable: tool calls, file reads/writes, commands, and errors
- Emit a structured event stream suitable for UIs and debugging
- Avoid “black boxes”: clients should be able to replay and audit what happened

### 4. Context Management - Minimal, Sufficient, Intentional

- Keep prompts minimal and explicit
- Use progressive disclosure for tools/docs rather than dumping everything up front
- Prefer on-demand loading of files and context

### 5. Separate Content from Details

Tool results should separate:
- **Content**: What the LLM sees (text/JSON)
- **Details**: What the UI/client uses for rendering (structured metadata)

This prevents models from parsing textual output meant for interfaces.

### 6. Practical Security, Context-Aware Controls

- Default to a permissive experience for trusted, single-user setups
- Provide optional sandboxing for untrusted or multi-tenant contexts
- Make capabilities explicit and configurable (what tools exist, what they can access)
