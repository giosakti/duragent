# `duragent doctor` — Installation & Configuration Diagnostics

## What is this?

A diagnostic subcommand that validates the duragent installation, configuration, and agent specs in a single run. Surfaces problems early — before `duragent serve` fails at runtime.

## The Problem

Setup failures are hard to diagnose:

- Missing `ANTHROPIC_API_KEY` only surfaces when an agent tries to call the LLM
- A typo in `agent.yaml` only surfaces when the agent is routed a message
- A referenced `SYSTEM_PROMPT.md` that doesn't exist silently results in no system prompt
- `0.0.0.0` bind without auth tokens is a security risk that's never warned about

Users troubleshoot these one at a time through trial and error. A single diagnostic command catches them all upfront.

## Design Principle

**Only check what the user has configured.** Never warn or error about features the user hasn't activated. If no gateway config exists, skip the Gateways section. The doctor should feel helpful, not noisy.

## Design

### Invocation

```
duragent doctor [--config duragent.yaml] [--format text|json]
```

Reads the same `--config` flag as other subcommands. Runs all checks, prints a structured report, exits with code 0 (all pass) or 1 (any errors). Default format is `text`; `--format json` outputs machine-readable JSON for CI or tooling integration.

### Check Categories

Each check produces one of three statuses:

| Status | Meaning |
|--------|---------|
| **OK** | Check passed |
| **WARN** | Non-fatal issue (works but suboptimal or risky) |
| **ERROR** | Fatal issue (will break at runtime) |

Sections with no applicable checks are omitted entirely.

#### 1. Config

Always runs.

| Check | Status | Condition |
|-------|--------|-----------|
| Config file loads | ERROR | File missing, invalid YAML, unclosed `${VAR}`, or `${VAR}` referencing unset env var |
| Workspace dir exists | ERROR | Workspace path (default: `.duragent/` relative to config) doesn't exist or isn't a directory |
| Agents dir exists | ERROR | Agents directory doesn't exist or isn't readable |
| Bind address parses | ERROR | `server.host` isn't a valid IP address |
| Data directories writable | ERROR | Workspace subdirs (sessions, schedules, etc.) exist but aren't writable |

Note: env var resolution (`${VAR}`, `${VAR:-default}`) happens during `Config::load()`. A missing required env var is caught by "Config file loads" — no separate check needed.

#### 2. Agents

Calls `FileAgentCatalog::load_all()` (the same `scan_agents` path used at startup) and reformats the `AgentScanResult`:

- Each successfully loaded agent → **OK** with agent name and provider
- Each `ScanWarning::InvalidAgent` → **ERROR** (bad YAML, wrong apiVersion/kind, etc.)
- Each `ScanWarning::MissingResource` → **WARN** (missing .md file, unknown builtin tool, invalid skill)
- Each `ScanWarning::AgentsDirMissing` → **ERROR** (already caught by Config section, but included for completeness)

**One additional check per loaded agent:** if `model.provider` is a cloud provider (Anthropic, OpenAI, OpenRouter), verify the corresponding env var or OAuth credentials exist. Ollama is exempt (no key required).

| Provider | Env var | Fallback |
|----------|---------|----------|
| Anthropic | `ANTHROPIC_API_KEY` | OAuth credentials at `~/.duragent/auth.json` |
| OpenAI | `OPENAI_API_KEY` | — |
| OpenRouter | `OPENROUTER_API_KEY` | — |
| Ollama | — (no key required) | — |

No new scanning logic needed — we reuse existing infrastructure and add one env var check.

#### 3. Gateways

**Only runs if gateways are configured** (i.e., `gateways.discord`, `gateways.telegram`, or `gateways.external` is present in config). Omitted entirely otherwise.

| Check | Status | Condition |
|-------|--------|-----------|
| Discord config valid | OK | `gateways.discord` section present — if config loaded successfully, `bot_token` resolved (env var failures caught at config load time) |
| Telegram config valid | OK | Same as Discord for `gateways.telegram` |
| External gateway command exists | ERROR | An entry in `gateways.external` has a `command` that doesn't exist or isn't executable |

Note: Gateway tokens (`bot_token`) are YAML string fields, typically populated via `${ENV_VAR}` syntax. If the env var is unset and has no default, config loading fails — caught in the Config section. The Gateways section only validates external gateway commands.

#### 4. Security

Always runs.

| Check | Status | Condition |
|-------|--------|-----------|
| Bind + auth | WARN | `server.host` is `0.0.0.0` and neither `admin_token` nor `api_token` is configured |
| Admin token strength | WARN | `admin_token` is set but shorter than 16 characters |

### Output Format

```
duragent doctor
===============

Config
  OK     Config loaded (duragent.yaml)
  OK     Workspace exists (.duragent/)
  OK     Agents directory exists (.duragent/agents/)
  OK     Bind address valid (127.0.0.1:8080)
  OK     Data directories writable

Agents
  OK     iova — valid, provider: anthropic (OAuth)
  OK     hiro — valid, provider: anthropic (API key)
  WARN   hiro — missing resource: ./INSTRUCTIONS.md

Security
  OK     Server binds to localhost only

10 checks passed, 1 warning, 0 errors
```

- Sections with no applicable checks are omitted (e.g., no "Gateways" if none configured).

### JSON Format

With `--format json`:

```json
{
  "status": "warn",
  "sections": [
    {
      "name": "Config",
      "checks": [
        { "status": "ok", "message": "Config loaded (duragent.yaml)" },
        { "status": "ok", "message": "Workspace exists (.duragent/)" }
      ]
    },
    {
      "name": "Agents",
      "checks": [
        { "status": "ok", "message": "iova — valid, provider: anthropic (OAuth)" },
        { "status": "warn", "message": "hiro — missing resource: ./INSTRUCTIONS.md" }
      ]
    }
  ],
  "summary": { "ok": 10, "warn": 1, "error": 0 }
}
```

Top-level `status` is the worst status across all checks: `"ok"`, `"warn"`, or `"error"`.

### Exit Code

- `0` — no errors (warnings are acceptable)
- `1` — one or more errors

## Implementation Steps

### Step 1: Add `Doctor` to CLI commands

**File: `crates/duragent/src/main.rs`**
- Add `Doctor` variant to `Commands` enum with `--format` arg (default: `text`, values: `text`/`json`) plus shared `--config`
- Dispatch to `commands::doctor::run()`

### Step 2: Create `commands/doctor.rs`

**File: `crates/duragent/src/commands/doctor.rs`**

Core structure:
```rust
pub async fn run(config_path: &Path) -> anyhow::Result<ExitCode> {
    let mut report = Report::new();

    let config = check_config(&mut report, config_path);
    let config = match config {
        Some(c) => c,
        None => return Ok(report.finish()), // can't proceed without config
    };

    check_agents(&mut report, &config, config_path);
    check_gateways(&mut report, &config);
    check_security(&mut report, &config);

    Ok(report.finish())
}
```

`check_agents` internally calls `FileAgentCatalog::load_all()`, maps the `AgentScanResult` to report entries, and adds provider env var checks per loaded agent.

### Step 3: Report types

**File: `crates/duragent/src/commands/doctor.rs`**

```rust
enum CheckStatus { Ok, Warn, Error }

struct CheckResult {
    status: CheckStatus,
    message: String,
}

struct Section {
    name: String,
    checks: Vec<CheckResult>,
}

struct Report {
    sections: Vec<Section>,
}
```

`Report::finish(format)` renders to text or JSON (omitting empty sections in both formats) and returns `ExitCode::SUCCESS` or `ExitCode::FAILURE`. Derive `Serialize` on the report types for JSON output.

### Step 4: Register the command

**File: `crates/duragent/src/commands/mod.rs`**
- Add `pub mod doctor;`

## Implementation Guidance

Reuse existing code where it makes sense, but keep doctor loosely coupled — it should call public APIs, not reach into module internals.

| What to check | Reuse | How |
|---------------|-------|-----|
| Config loading | `Config::load(path)` | Call directly; catch errors for report |
| Agent scanning | `FileAgentCatalog::load_all()` | Construct catalog with resolved paths from config, call `load_all()`, map `AgentScanResult` fields to report entries |
| Provider env vars | `std::env::var()` | Simple env var checks; don't construct `ProviderRegistry` (heavy, logs warnings as side effects). Check `auth.json` existence for OAuth fallback. |
| External gateway commands | `which` crate or `Command::new().arg("--version")` | Check if command exists in PATH |
| Path/dir checks | `std::fs::metadata()` | Check existence and permissions |

## Files Changed

| File | Change |
|------|--------|
| `crates/duragent/src/main.rs` | Add `Doctor` command variant + dispatch |
| `crates/duragent/src/commands/mod.rs` | Add `pub mod doctor` |
| `crates/duragent/src/commands/doctor.rs` | New — all diagnostic logic |

## Non-Goals (for now)

- **CLI tool PATH check** — validating that `type: cli` tool commands exist in PATH. Low value for v1; add when users report issues.
- **tmux check** — useful but niche. Only matters for `background_process` interactive mode. Add later if needed.
- **Connectivity test** (ping LLM endpoints) — adds latency, may fail behind proxies. Can add later as `--check-connectivity` flag.
- **Port availability check** (try binding) — conflicts if server is already running.
- **Fix mode** (`duragent doctor --fix`) — too much magic. Report problems, let the user fix them.

## Verification

1. `cargo build` — compiles clean
2. `cargo test` — unit tests for Report formatting and provider check logic
3. Manual: run `duragent doctor` with valid config, missing env var, broken agent.yaml
