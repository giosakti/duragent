# Session Lifecycle Management

**Status:** Implemented
**Priority:** P1–P2

## The Problem

Sessions are created but never end. There is no mechanism to reset, delete, expire, or clean up sessions. For a runtime designed to be long-running and self-hosted, this causes:

| Problem | Impact | Priority |
|---------|--------|----------|
| No `/reset` command for gateway users | Users can't start fresh when conversation goes off-track | P1 |
| No DELETE session API endpoint | Operators can't clean up sessions programmatically | P1 |
| `events.jsonl` grows unbounded | Disk fills up over time | P2 |
| Abandoned sessions never expire | Memory leak (actor tasks) and disk waste | P2 |

These are all facets of the same missing capability: **session lifecycle management**.

## 1. Gateway Slash Commands

### Problem

Gateway users (Telegram, Discord) have no way to start a fresh session. The `ChatSessionCache` maps `(gateway, chat_id, agent)` to a session forever. Even with context window management (see context-window-management spec), users will want to manually reset for a clean slate.

### Solution

Add slash commands recognized by the gateway handler via an extensible command dispatcher. Before routing to an agent, check if the message text starts with `/`:

```rust
// In gateway/handler.rs, early in handle_message()
if let Some(command) = text.trim().strip_prefix('/') {
    return self.handle_command(command, gateway, &routing.chat_id).await;
}
```

Unknown commands return `None` and fall through to regular message processing. This avoids breaking messages that happen to start with `/` on platforms where that's common.

### Commands

| Command | Behavior |
|---------|----------|
| `/reset` | End current session, next message starts fresh |
| `/status` | Show current session info (id, agent, status, created time) |

The `handle_reset_command` method:
1. Finds the current session via `find_session_for_chat()`
2. Sets status to `Completed`
3. Removes from `ChatSessionCache`
4. Removes from `SessionRegistry`
5. Sends a reply: "Session reset. Send a message to start a new conversation."

The `handle_status_command` method:
1. Finds the current session via `find_session_for_chat()`
2. Gets session metadata
3. Sends a reply with session id, agent, status, and creation time

Both commands return a user-facing message if no active session exists.

## 2. DELETE Session API Endpoint

### Problem

The `SessionStore::delete()` method exists and works (`FileSessionStore` removes the directory), but nothing exposes it. Operators have no API to manage sessions.

### Solution

Add `DELETE /api/v1/sessions/{session_id}`.

### Behavior

1. Set session status to `Completed` (graceful — lets actor flush)
2. Remove from `SessionRegistry`
3. Remove from `ChatSessionCache` (if it's a gateway session)
4. Delete from `SessionStore` (removes `events.jsonl` and `state.yaml`)
5. Return `204 No Content`

If the session doesn't exist, return `404`.

### Implementation

Handler in `handlers/v1/sessions.rs`, registered in `server.rs`:

```rust
.route("/sessions/{session_id}",
    get(handlers::v1::get_session).delete(handlers::v1::delete_session),
)
```

## 3. Event Log Compaction

### Problem

`events.jsonl` is append-only and grows forever. Every user message, assistant message, tool call, tool result, status change, and error is appended. For active gateway sessions, this file can grow to megabytes quickly.

Snapshots (`state.yaml`) already checkpoint conversation state, but events before the checkpoint are never cleaned up.

### Solution

Add event log compaction that runs after a successful snapshot. Events with `seq <= checkpoint_seq` are no longer needed for recovery (the snapshot contains their effect).

### Configuration

Compaction mode is configurable globally in `duragent.yaml` and per-agent in the agent spec:

```yaml
# duragent.yaml (global default)
sessions:
  compaction: discard       # discard (default) | archive | disabled
```

```yaml
# agent.yaml (per-agent override)
session:
  compaction: archive       # overrides global setting for this agent
```

| Mode | Behavior |
|------|----------|
| `discard` | Remove old events after snapshot (default) |
| `archive` | Append old events to `events.archive.jsonl` before removing |
| `disabled` | No compaction (`events.jsonl` grows unbounded) |

### Implementation

The `SessionStore` trait has a `compact_events` method:

```rust
async fn compact_events(
    &self,
    session_id: &str,
    up_to_seq: u64,
    archive: bool,
) -> StorageResult<()>;
```

For `FileSessionStore`:
1. Read all lines from `events.jsonl`
2. Separate into old (`seq <= up_to_seq`) and retained (`seq > up_to_seq`)
3. If `archive`: append old lines to `events.archive.jsonl`
4. Write retained lines to `events.jsonl.tmp`, then atomic rename

Called in `SessionActor::write_snapshot()` after the snapshot succeeds:

```rust
// After successful snapshot
if self.checkpoint_seq > 0 && self.compaction_mode != CompactionMode::Disabled {
    let archive = self.compaction_mode == CompactionMode::Archive;
    if let Err(e) = self.store.compact_events(&self.id, self.checkpoint_seq, archive).await {
        debug!(session_id = %self.id, error = %e, "Event compaction failed (non-fatal)");
    }
}
```

Compaction failure is non-fatal — the file just stays larger until next snapshot.

## 4. Session TTL & Auto-Expiry

### Problem

Abandoned sessions stay active forever. Each active session has:
- A running actor task (memory)
- A `DashMap` entry in the registry (memory)
- Files on disk (`events.jsonl`, `state.yaml`)

For self-hosted deployments with many gateway users, this is a slow resource leak.

### Solution

Add a configurable session TTL. Sessions that haven't received a message within the TTL are automatically completed.

### Configuration

Global default in `duragent.yaml` and per-agent override in the agent spec:

```yaml
# duragent.yaml
sessions:
  ttl_hours: 168    # 7 days (default). 0 disables auto-expiry.
```

```yaml
# agent.yaml (per-agent override)
session:
  ttl_hours: 24     # override for this agent
```

### Implementation

A periodic cleanup task (spawned in `commands/serve.rs`, runs every hour) that:

1. Iterates all sessions in the registry
2. Skips `Completed` sessions
3. Checks per-agent TTL override (falls back to global if not set)
4. For expired sessions:
   - Sets status to `Completed`
   - Removes from `ChatSessionCache`
   - Removes from `SessionRegistry`
5. Does NOT delete files (preserves history for audit)

Setting `ttl_hours: 0` disables auto-expiry entirely (no background task spawned).

Expired gateway sessions automatically get a fresh session on the next message (because `ChatSessionCache` validator will find the session gone).

## Acceptance Criteria

### Gateway Slash Commands
- [x] `/reset` command in gateway chats ends the current session
- [x] Next message after `/reset` creates a fresh session
- [x] Confirmation message is sent to the user
- [x] Works for both DM and group chats
- [x] `/status` command shows session info
- [x] Unknown commands fall through to regular processing

### DELETE API
- [x] `DELETE /api/v1/sessions/{session_id}` removes a session
- [x] Returns 204 on success, 404 if not found
- [x] Session files are cleaned up from disk
- [x] Gateway cache is invalidated if applicable

### Event Log Compaction
- [x] Events covered by snapshots are pruned from `events.jsonl`
- [x] Compaction runs automatically after each snapshot
- [x] Recovery still works correctly after compaction
- [x] Compaction failure does not affect normal operation
- [x] Configurable modes: discard, archive, disabled
- [x] Per-agent compaction mode override

### Session TTL
- [x] Sessions expire after configurable inactivity period
- [x] Default TTL is 7 days
- [x] Per-agent TTL override is supported
- [x] Expired sessions are completed, not deleted (preserves history)
- [x] Gateway users get a fresh session after expiry
- [x] TTL of 0 disables auto-expiry

## Out of Scope

- Session archival (moving old sessions to cold storage)
- Session transfer (moving a session between agents)
- Disk quota enforcement
- Session size limits (max messages per session)

## Implementation Order

1. **DELETE API** — smallest change, unblocks manual cleanup
2. **Gateway Slash Commands** — high user-facing value, extensible dispatcher
3. **Event Log Compaction** — configurable modes, builds on existing snapshot logic
4. **Session TTL** — background task, per-agent override
