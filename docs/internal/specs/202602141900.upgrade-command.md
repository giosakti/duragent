# `duragent upgrade` — Self-Update the Binary

## What is this?

A subcommand that upgrades the duragent binary to the latest release (or a specific version) by downloading the appropriate platform binary from GitHub Releases. When a server is running, it can perform an exec-restart to apply the new binary without manual intervention.

## The Problem

Duragent is distributed as a single statically-linked binary. Today, upgrading requires the user to manually:

1. Check if a new version exists
2. Download the right binary for their platform
3. Replace the existing binary (finding where it's installed, handling permissions)
4. Restart the server

This is friction that discourages staying up-to-date. Other single-binary tools (rustup, gh, flyctl) solve this with a self-update command. Duragent should too.

Additionally, since duragent agents have access to the bash tool, an agent should be able to upgrade its own runtime — a true self-upgrade.

## User Scenarios

**Check for updates:**
```
$ duragent upgrade --check
Current: v0.5.0
Latest:  v0.6.0

Run `duragent upgrade` to update.
```

**Upgrade to latest:**
```
$ duragent upgrade
Current: v0.5.0
Latest:  v0.6.0

Downloading duragent v0.6.0 for x86_64-unknown-linux-gnu...
Downloaded 12.3 MB
Verifying checksum... OK
Replacing binary at /usr/local/bin/duragent...
Upgraded to v0.6.0
```

**Already up to date:**
```
$ duragent upgrade
Current: v0.5.0 (latest)
Already up to date.
```

**Upgrade to specific version:**
```
$ duragent upgrade --version 0.4.0
Current: v0.5.0
Target:  v0.4.0

Downloading duragent v0.4.0 for x86_64-unknown-linux-gnu...
...
Downgraded to v0.4.0
```

**Upgrade + restart a running server:**
```
$ duragent upgrade --restart
Current: v0.5.0
Latest:  v0.6.0

Downloading duragent v0.6.0 for x86_64-unknown-linux-gnu...
Verifying checksum... OK
Replacing binary...
Restarting server...
[server shuts down gracefully, execs new binary, comes back up]
```

**Agent self-upgrade (via bash tool in a session):**
```
Agent runs: duragent upgrade --restart
→ Binary replaced on disk
→ Graceful shutdown (sessions flushed to disk)
→ exec() replaces process with new binary + same args
→ New server starts, recovers sessions from disk
→ Agent session resumes where it left off
```

## Design

### Invocation

```
duragent upgrade [--check] [--version <VERSION>] [--restart] [--format text|json]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--check` | false | Only check for updates, don't install |
| `--version` | latest | Target a specific version (e.g., `0.6.0` or `v0.6.0`) |
| `--restart` | false | After replacing the binary, restart a running server via exec |
| `--format` | text | Output format (`text` or `json`) |

### Version Discovery

Query the GitHub Releases API:

- **Latest version:** `GET https://api.github.com/repos/giosakti/duragent/releases/latest`
- **Specific version:** `GET https://api.github.com/repos/giosakti/duragent/releases/tags/v{version}`

Parse the `tag_name` field (format: `v0.6.0`) and compare with `build_info::VERSION`.

No authentication required for public repos. Rate limit is 60 requests/hour for unauthenticated requests — more than enough for upgrade checks.

### Platform Detection

Detect the current platform at runtime and map to release artifact names:

| `(OS, ARCH)` | Artifact name |
|---------------|--------------|
| `(linux, x86_64)` | `duragent-x86_64-unknown-linux-gnu.tar.gz` |
| `(macos, x86_64)` | `duragent-x86_64-apple-darwin.tar.gz` |
| `(macos, aarch64)` | `duragent-aarch64-apple-darwin.tar.gz` |

These match the existing release workflow matrix exactly. Unsupported platforms get a clear error: `"No pre-built binary for {os}/{arch}. Build from source: cargo install ..."`.

### Download and Verification

1. Find the asset URL from the release's `assets` array (match by artifact name)
2. Download to a temp file in the same directory as the current binary (ensures same filesystem for atomic rename)
3. Extract the binary from the `.tar.gz` archive
4. Verify SHA256 checksum against `checksums.sha256` from the release (warn and continue if checksum file absent — for older releases)
5. Verify the extracted binary runs (`./duragent.upgrade.tmp --version`)
6. Set executable permissions (`chmod 755`)

### Binary Replacement

On Unix, `rename()` on the same filesystem is atomic — it replaces the destination in a single operation. No intermediate state where the binary is missing.

```
1. Download + extract to <binary_dir>/duragent.upgrade.tmp
2. Verify checksum + test execution
3. rename(duragent.upgrade.tmp, duragent)    ← atomic, single step
```

The old binary's inode stays on disk as long as any running process holds a file descriptor to it. The rename only changes the directory entry. If any step before the rename fails, the original binary is completely untouched.

**Failure modes:**

| Failure | State after | Recovery |
|---------|-------------|----------|
| Network error during download | Original binary intact, temp file partial/absent | Re-run `duragent upgrade` |
| Checksum mismatch | Original binary intact, temp file deleted | Re-run (may indicate tampering — error message explains) |
| New binary fails `--version` test | Original binary intact, temp file deleted | Report corrupt download, suggest re-run |
| Permission denied on rename | Original binary intact, temp file remains | `sudo duragent upgrade` or move binary to writable location |
| Crash/kill during download | Original binary intact | Re-run |
| Crash/kill during rename | Atomic — either old or new binary is in place | No action needed |

There is no failure mode where the binary is missing. The atomic rename is the only mutation, and it either completes or doesn't.

**Permissions:** The binary replacement requires write access to the directory containing the binary. If the binary is in `/usr/local/bin/` and the user isn't root, the command fails with a clear message: `"Permission denied. Try: sudo duragent upgrade"`.

### Server Restart via exec

When `--restart` is passed, after replacing the binary on disk, the upgrade command signals the running server to perform an exec-restart. This reuses the existing graceful shutdown path, then replaces the process:

```
Graceful shutdown (existing code in serve.rs):
  1. Abort process cleanup task
  2. process_registry.shutdown()
  3. scheduler_handle.shutdown()
  4. session_registry.shutdown()     ← flushes events + snapshots to disk
  5. gateways.shutdown()
  6. background_tasks.shutdown()

Exec (new):
  7. std::process::Command::new(std::env::current_exe()?).args(std::env::args().skip(1)).exec()
```

`exec()` replaces the current process image with the new binary. Same PID, same arguments, fresh start. On startup, the new binary runs `session_registry.recover()` and resumes persisted sessions.

**How `--restart` triggers the exec:**

The upgrade command calls the server's existing shutdown HTTP endpoint with a new query parameter or header indicating "restart after shutdown". The server's shutdown handler, instead of exiting after the graceful shutdown sequence, calls `exec()`.

Alternatively (simpler): the upgrade command calls the shutdown endpoint, then immediately execs the new binary with the same serve arguments. This avoids modifying the server's shutdown path — the upgrade process itself becomes the new server.

The simpler approach is preferred:

```
upgrade --restart flow:
  1. Download + replace binary (same as normal upgrade)
  2. Read server's config to determine serve arguments
  3. Call POST /admin/shutdown on the running server
  4. Wait for server to exit (poll health endpoint, or short sleep)
  5. exec() the new binary with the original serve arguments
```

This keeps the upgrade and serve commands decoupled. The upgrade command doesn't need to be running inside the server process.

**Agent self-upgrade:** An agent calls `duragent upgrade --restart` via bash. The bash tool runs the command. The server shuts down gracefully (flushing the agent's session to disk), then execs the new binary. The new server starts, recovers sessions, and the agent's session resumes. From the agent's perspective, there's a brief interruption — the in-flight bash tool call never returns (the process was replaced), but the session is recovered and the agent can continue.

### Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Upgrade successful, or `--check` found no update needed |
| 1 | Error (network, permissions, etc.) |

With `--check`: exit 0 regardless of whether an update is available (it's informational).

With `--restart`: the process execs into the new server, so it never actually exits with a code. If the exec fails, exit 1.

### JSON Output

```json
{
  "current_version": "0.5.0",
  "latest_version": "0.6.0",
  "update_available": true,
  "action": "upgraded",
  "target": "x86_64-unknown-linux-gnu"
}
```

For `--check`:
```json
{
  "current_version": "0.5.0",
  "latest_version": "0.6.0",
  "update_available": true,
  "action": "check"
}
```

## Implementation

### Release Workflow Changes

**File: `.github/workflows/release.yml`**

Add a checksum step after artifact collection:

```yaml
- name: Generate checksums
  run: |
    cd artifacts
    sha256sum * > checksums.sha256
    cat checksums.sha256
```

Include `checksums.sha256` in the release (already covered by `files: artifacts/*`).

### CLI Changes

**File: `crates/duragent/src/main.rs`**

Add `Upgrade` variant to `Commands` enum:

```rust
/// Upgrade duragent to the latest version
Upgrade {
    /// Only check for updates, don't install
    #[arg(long)]
    check: bool,
    /// Target version (default: latest)
    #[arg(long)]
    version: Option<String>,
    /// Restart a running server after upgrade
    #[arg(long)]
    restart: bool,
    /// Output format (text or json)
    #[arg(long, default_value = "text")]
    format: String,
},
```

**File: `crates/duragent/src/commands/mod.rs`**

Add `pub mod upgrade;`

### Upgrade Module

**File: `crates/duragent/src/commands/upgrade.rs`**

```
pub async fn run(check_only, target_version, restart, format) -> Result<()>
```

Core flow:

1. `current_version()` — read from `build_info::VERSION`
2. `fetch_release(target_version)` — call GitHub API, parse JSON response
3. Compare versions — if same, report "up to date" and return
4. If `check_only`, print info and return
5. `detect_target()` — platform detection via `std::env::consts`
6. `find_asset(release, target)` — find matching archive in release assets
7. `download_asset(url, temp_path)` — HTTP GET to temp file
8. `verify_checksum(temp_path, release)` — download + verify SHA256 if available
9. `extract_binary(archive_path)` — untar the archive to `duragent.upgrade.tmp`
10. `test_binary(tmp_path)` — run `--version` to verify it works
11. `rename(tmp_path, current_binary_path)` — atomic replacement
12. If `restart`: call shutdown endpoint, wait, `exec()` new binary with serve args

### Dependencies

HTTP client for GitHub API and downloads. Evaluate:

- **`reqwest`** — already in `Cargo.lock` (used by the Anthropic LLM client). Reuse it.
- **`flate2` + `tar`** — for extracting `.tar.gz` archives. Small, well-maintained crates.

No new heavyweight dependencies needed.

### Platform Target Constant

```rust
fn detect_target() -> Result<&'static str> {
    match (std::env::consts::OS, std::env::consts::ARCH) {
        ("linux", "x86_64") => Ok("x86_64-unknown-linux-gnu"),
        ("macos", "x86_64") => Ok("x86_64-apple-darwin"),
        ("macos", "aarch64") => Ok("aarch64-apple-darwin"),
        (os, arch) => bail!(
            "No pre-built binary for {os}/{arch}. \
             Build from source: cargo install --git https://github.com/giosakti/duragent.git"
        ),
    }
}
```

### Files Changed

| File | Change |
|------|--------|
| `.github/workflows/release.yml` | Add checksum generation step |
| `crates/duragent/src/main.rs` | Add `Upgrade` command variant + dispatch |
| `crates/duragent/src/commands/mod.rs` | Add `pub mod upgrade` |
| `crates/duragent/src/commands/upgrade.rs` | New — version check, download, replace, restart logic |
| `Cargo.toml` | Add `flate2` and `tar` dependencies |

### Tests

- Unit: `detect_target()` returns a valid target for the current platform
- Unit: version comparison (newer, same, older, pre-release)
- Unit: asset name matching logic
- Integration: mock GitHub API response, verify correct asset selected
- Manual: `duragent upgrade --check`, `duragent upgrade`, `duragent upgrade --version <older>`
- Manual: `duragent upgrade --restart` with a running server

## Acceptance Criteria

- [ ] `duragent upgrade --check` shows current and latest version
- [ ] `duragent upgrade` downloads and replaces the binary atomically
- [ ] `duragent upgrade --version X.Y.Z` installs a specific version
- [ ] Platform auto-detected; unsupported platforms get clear error
- [ ] Checksum verified when `checksums.sha256` is present in the release
- [ ] Binary replacement is atomic (single `rename()`, no intermediate missing state)
- [ ] New binary tested with `--version` before replacing current
- [ ] Permission errors produce actionable message
- [ ] `--format json` outputs machine-readable JSON
- [ ] Release workflow generates `checksums.sha256`
- [ ] `--restart` triggers graceful shutdown + exec into new binary
- [ ] Sessions survive restart (flushed before shutdown, recovered on startup)
- [ ] Agent-initiated self-upgrade works via bash tool

## Out of Scope

- **Channels** (stable/beta/nightly) — unnecessary complexity for now. Duragent has a single release track. Add channels when/if pre-release distribution is needed.
- **Automatic update checks** — no background checks or "update available" banners on `duragent serve` startup. Users run `duragent upgrade --check` when they want to know.
- **Rollback command** — if users need rollback, they can `duragent upgrade --version <previous>`.
- **Signature verification** (GPG/cosign) — checksums are sufficient for integrity. Code signing can be added later without changing the user-facing command.
- **Windows support** — no Windows target in the release matrix today. Add when Windows is supported.
- **`cargo install` path** — this command only handles pre-built binary upgrades. Users who installed via `cargo install` should continue using `cargo install --git` to upgrade.
