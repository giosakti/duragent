# Background Processes

## What is this?

Infrastructure for spawning, monitoring, and interacting with long-running background processes. Enables agents to delegate work to external CLI tools (coding agents, builds, tests, scripts) and track them to completion.

## The Problem

Current tools are synchronous — the agent calls a tool, waits for the result (up to 2 minutes), and continues. This blocks use cases like:
- "Use Claude Code to implement this feature" (10-30 minutes)
- "Run the full test suite and tell me what fails" (5+ minutes)
- "Spawn 3 coding agents to fix these issues in parallel"
- "Start a build, monitor it, and deploy if it succeeds"

## User Scenarios

### Scenario 1: Simple delegation (synchronous)
1. User: "Have Claude Code add input validation to the API"
2. Agent calls `spawn_process` with `wait: true`
3. Tool blocks until Claude Code finishes
4. Agent reads the JSON result, summarizes what changed

### Scenario 2: Fire and forget
1. User: "Run the full test suite and tell me when it's done"
2. Agent calls `spawn_process` with `wait: false`
3. Tool returns immediately with `{handle: "proc-abc"}`
4. Agent tells user: "Tests are running, I'll let you know when they finish"
5. Process completes → completion event injected into session
6. Fresh agentic loop runs → agent reads result, reports to user

### Scenario 3: Parallel coding agents
1. User: "Fix issues #12, #13, and #14 in parallel"
2. Agent spawns 3 processes (one per issue) with `wait: false`
3. As each completes, completion events arrive
4. Agent summarizes results as they come in

### Scenario 4: Active monitoring with intervention
1. User: "Use Claude Code to refactor the auth module, but I want you to review what it does"
2. Agent spawns Claude Code in interactive mode inside tmux
3. Agent periodically reads the screen via `process` tool's `capture` action
4. When Claude Code asks to delete a file, agent reviews and sends "n" via `send_keys`
5. Human can also `tmux attach` at any time to watch or take over

### Scenario 5: Human observation
1. Agent spawns a coding agent for a complex task
2. Agent tells user: "Running in tmux session `task-42`. Attach with `tmux attach -t task-42` to watch."
3. Human attaches, watches Claude Code work in real-time
4. Human detaches, agent continues monitoring
5. Process completes, agent reports results

## Core Features

### Process Registry
- In-memory map of spawned processes, keyed by process handle
- Backed by on-disk metadata (`.meta.json` per process) for crash recovery
- Tracks: handle, command, PID, status, tmux session name, log file path, spawning session
- Scoped per agent session (processes from session A not visible to session B)

### Two spawn modes

**Without tmux** (always available):
- Plain subprocess with stdout/stderr piped to log file
- Agent reads structured output from log file
- No human observation, no agent interaction mid-process
- Good for: simple delegation, fire-and-forget

**With tmux** (when tmux is available):
- Process runs inside a tmux session
- Agent can read screen via `tmux capture-pane -t <session> -p`
- Agent can send input via `tmux send-keys -t <session> "<keys>" Enter`
- Human can observe via `tmux attach -t <session>`
- Good for: interactive coding agents, tasks needing oversight

### Completion callbacks
- When a process exits, inject a message into the spawning session
- Message includes: exit code, final output (tail), runtime duration
- This triggers a fresh agentic loop run (same pattern as scheduled tasks)
- Only fires if `wait: false` (synchronous mode handles it inline)

### Tools

**`spawn_process`** — Start a background command:
```json
{
  "command": "claude -p 'build feature X' --output-format stream-json",
  "workdir": "/path/to/project",
  "wait": false,
  "tmux": true,
  "label": "build-feature-x"
}
```

Returns (when `wait: false`):
```json
{
  "handle": "proc-abc123",
  "tmux_session": "duragent-proc-abc123",
  "status": "running",
  "pid": 12345
}
```

Returns (when `wait: true`):
```json
{
  "status": "completed",
  "exit_code": 0,
  "output": "... stdout/stderr content ...",
  "duration_seconds": 142
}
```

**`process`** — Interact with running processes:

| Action | Description | Requires tmux |
|--------|-------------|---------------|
| `list` | List all processes for this session | No |
| `status` | Check if a process is running/completed/failed | No |
| `log` | Read process output from log file (with offset/limit) | No |
| `capture` | Capture current screen content (clean text) | Yes |
| `send_keys` | Send keystrokes to process | Yes |
| `write` | Write to process stdin | No (but limited without tmux) |
| `kill` | Terminate a process | No |

## Implementation Notes

### Process lifecycle

```
spawn_process called
  ├─ tmux available + tmux:true?
  │   ├─ Yes: tmux new-session -d -s <name> "<command> 2>&1 | tee <logfile>"
  │   └─ No:  tokio::process::Command, pipe stdout/stderr to <logfile>
  ├─ Register in ProcessRegistry
  ├─ wait:true? → block until exit, return result
  └─ wait:false? → return handle immediately
         └─ on exit → inject completion message into session
```

### Log file location
```
.duragent/processes/<handle>.log       # raw output (stdout/stderr)
.duragent/processes/<handle>.meta.json # metadata (command, pid, status, timestamps)
```

### tmux session naming
```
duragent-<handle>    # e.g., duragent-proc-abc123
```

### Completion callback injection

When a process exits (and `wait: false`):
1. Read final output from log file (last N chars)
2. Build a message: `[Background Process Completed]\n\nHandle: {handle}\nLabel: {label}\nCommand: {command}\nExit code: {code}\nDuration: {duration}\n\nOutput (last 2000 chars):\n{tail}`
3. Inject as user message into the spawning session via `SessionHandle::add_user_message()`
4. Trigger a fresh agentic loop run (same as scheduled tasks)

### Crash recovery

tmux sessions and log files survive Duragent crashes. On startup:

1. Scan `.duragent/processes/*.meta.json` for entries marked `"running"`
2. For each, check if tmux session still exists: `tmux has-session -t <name>`
3. If tmux session alive → re-register in ProcessRegistry, resume exit monitoring
4. If tmux session gone → check log file for final output, mark as `"lost"`
5. For non-tmux processes → mark as `"lost"` (no way to re-attach to a plain subprocess)
6. Fire completion callbacks for any processes that finished while Duragent was down

The `.meta.json` file is updated on every state transition (spawned → running → completed/failed/lost) using atomic writes (temp file + rename), consistent with Duragent's existing file persistence pattern.

### Process registry cleanup
- Completed/lost processes kept for 30 minutes (configurable), then removed
- Log files and metadata cleaned up with the registry entry

### Timeout
- Default: 30 minutes (configurable per spawn call via `timeout_seconds`)
- On timeout: SIGTERM, wait 5s, SIGKILL
- Reported as distinct `timed_out` status (separate from `failed`)

### Synchronous mode timeout
- When `wait: true`, the tool blocks the agentic loop
- Must increase tool execution timeout for this case (not the default 2 min)
- Implementation: tool checks `wait` param and sets appropriate timeout on sandbox exec

## Acceptance Criteria

- [ ] Agent can spawn a background process and get a handle back immediately
- [ ] Agent can spawn a process and wait synchronously for the result
- [ ] Agent can list, check status, read logs, and kill running processes
- [ ] When tmux is available, processes spawn inside tmux sessions
- [ ] Agent can capture tmux pane content and send keystrokes
- [ ] Human can `tmux attach` to observe a running process
- [ ] Completed processes inject a message back into the spawning session
- [ ] Processes have configurable timeouts with graceful shutdown
- [ ] Everything works without tmux (degraded: no capture/send_keys/attach)
- [ ] Process registry persists to disk and recovers after Duragent restart
- [ ] tmux processes are re-adopted on restart; non-tmux processes marked as lost

## Out of Scope (v1)

- Nested process spawning (process spawns another process)
- Resource limits (CPU/memory capping on spawned processes)
- Remote process spawning (processes always local)
- Built-in terminal emulator / web-based observation UI
- PTY allocation without tmux (could add via `portable-pty` crate later)

## Future Enhancements

- **Web observation UI**: Stream process output via SSE to a browser-based terminal viewer
- **Resource limits**: cgroups or bubblewrap constraints on spawned processes
- **Process groups**: Spawn N processes as a group, wait for all/any to complete
- **PTY without tmux**: Use `portable-pty` crate for direct PTY allocation (enables agent interaction without tmux dependency)
