# Project Charter: Agnx

## Vision

**Agnx** is a durable, portable runtime for AI agents.

- **Sessions that survive** — crash, restart, reconnect from any terminal: agnx is durable by design
- **Transparent state** — agent specs, memories, and sessions are human-readable files you can inspect, version, and export
- **Sandboxed by default** — bubblewrap on Linux; Docker or trust mode on other platforms
- **Pluggable everything** — file-based by default; bring your own storage or messaging backends
- **Edge-ready** — single-binary core (~10MB), gateway plugins are optional separate binaries

Core protocols built-in (CLI, HTTP, SSE). Platform integrations via plugins.

Self-host it directly, or use it as the foundation for agent-powered products.

## Problem Statement

Current agent frameworks require either buying into a heavy framework, using proprietary cloud-only services with no export path, running full container infrastructure for basic sandboxing, or building session persistence from scratch.

Agnx fills the gap: a lightweight, portable runtime for durable sessions and transparent state that you can build on.

## Goals

### Primary Goals

1. **Durable sessions** — Sessions survive crashes, restarts, and reconnects; attach from any terminal
2. **Transparent, portable state** — Agent specs, memories, and sessions are human-readable files
3. **Lightweight sandboxing** — Bubblewrap for lightweight isolation; support for more will be added
4. **Pluggable backends** — File-based by default; optional external storage (Postgres, Redis, S3)
5. **Core protocols built-in** — CLI/TUI, HTTP REST, SSE for real-time streaming
6. **Platform plugins** — Telegram, Discord, Slack via subprocess plugin protocol
7. **Standards-compliant** — MCP for tools, A2A for discovery
8. **LLM-agnostic** — OpenRouter (v0.1), OpenAI/Anthropic/Ollama (v0.2+), any OpenAI-compatible API
9. **Single binary** — ~10MB core, starts in milliseconds; gateway plugins ship separately

### Secondary Goal: Edge & Embedded Capability

Agnx should run on resource-constrained devices (Raspberry Pi, edge servers, IoT gateways):

- **Single binary** — no additional software to install for core runtime
- **Low memory footprint** — Target <50MB runtime memory
- **ARM-native** — First-class support for ARM64 and ARM32
- **Offline-capable** — Works with local LLMs without internet
- **Crash-resilient** — Immediate persistence ensures graceful recovery from power loss

## Non-Goals (v1.0)

- Web UI or visual builder
- Complex multi-agent protocols (we support supervisor→worker patterns, not mesh)
- Built-in RAG/vector search (use MCP tools)
- Workflow/DAG execution engine
- User authentication (application layer concern)
- Competing with llama.cpp/Ollama on inference (we integrate with them)
- Competing with Claude Code/OpenCode/Aider (we orchestrate them)

## Design Principles

### 1. Durable by Default

- Sessions survive crashes, restarts, and reconnects
- State is always persisted before execution continues
- No hidden in-memory state that disappears on failure

### 2. Transparent & Portable

- Agent specs are human-readable YAML + Markdown
- State files are inspectable (JSONL, YAML, Markdown)
- Export everything, migrate anywhere

### 3. Lean Core, Pluggable Edges

- Core protocols built-in (CLI, HTTP, SSE)
- Platform integrations via plugins
- Storage backends are swappable
- Add features only when real use cases demand them

### 4. Practical Security

- Trust mode for local development
- Lightweight sandboxing (bubblewrap) for isolation without Docker
- Heavier isolation is on the roadmap
- Capabilities are explicit and configurable

### 5. Observability-First

- Structured event stream for all operations
- Tool calls, file operations, and errors are inspectable
- Clients can replay and audit what happened

## Tech Stack

| Component | Choice | Rationale |
|-----------|--------|-----------|
| Language | Rust | Fast, compact binaries (~10MB), single-binary deployment, ARM support |
| HTTP | axum | Async, performant, SSE support |
| CLI | clap + ratatui | Standard CLI + modern TUI |
| Config | YAML + Markdown | Structured config + human-readable prompts |
| Serialization | serde | De facto Rust standard |
| State store | Filesystem (default) | Zero dependencies, portable |
| LLM Client | reqwest | No heavy SDK dependencies |
| MCP Client | Custom | Direct protocol implementation |

## Standards Alignment

| Standard | How Agnx Aligns |
|----------|------------------|
| **[A2A Protocol](https://a2a-protocol.org/)** | Agent Card for discovery |
| **[MCP](https://modelcontextprotocol.io/)** | Tools integrate via MCP protocol |
| **[AGENTS.md](https://agents.md/)** | Supports AGENTS.md for repository context |

## Roadmap

### v0.1.0 — Foundation

- [ ] Agent spec loader (YAML + Markdown)
- [ ] Single LLM provider (OpenRouter)
- [ ] Basic agent executor
- [ ] Core gateways: CLI, HTTP REST
- [ ] `agnx serve`, `agnx chat`

### v0.2.0 — Sessions & Durability

- [ ] Session persistence (JSONL + YAML snapshots)
- [ ] Session resume on reconnect
- [ ] `agnx attach` (connect to running session)
- [ ] Core gateways: SSE streaming

### v0.3.0 — Sandbox

- [ ] Sandbox interface + auto-selection
- [ ] bubblewrap backend (Linux)
- [ ] Docker backend (cross-platform fallback)
- [ ] Trust mode (no isolation)

### v0.4.0 — Tools & Memory

- [ ] CLI tool support (lightweight alternative to MCP)
- [ ] MCP tool integration
- [ ] File-based memory backend
- [ ] Agent export/import
- [ ] `agnx export`, `agnx import`

### v0.5.0 — Gateway Plugins

- [ ] Gateway plugin protocol (JSON over stdio)
- [ ] First-party plugin: agnx-gateway-telegram
- [ ] Plugin configuration in agnx.yaml

### v0.6.0 — External Backends

- [ ] Services: PostgreSQL backend
- [ ] Services: Redis backend
- [ ] Services: S3 backend

### v0.7.0 — Agent Orchestration

- [ ] Built-in tool: `claude_code_exec`
- [ ] Built-in tool: `opencode_exec`
- [ ] Supervisor agent pattern
- [ ] Worker session tracking
- [ ] Async notifications
- [ ] Inbound webhooks

### v1.0.0 — Stable Release

- [ ] Stable API (no breaking changes)
- [ ] Full documentation
- [ ] Published to package managers
- [ ] Helm chart for Kubernetes
- [ ] Security audit

## References

### Standards

- [A2A Protocol](https://a2a-protocol.org/)
- [Model Context Protocol](https://modelcontextprotocol.io/)
- [AGENTS.md](https://agents.md/)

### Inspiration

- [Ollama](https://ollama.com/) — Proved single-binary local LLM is viable
- [nginx](https://nginx.org/) — Stateless, config-driven, ubiquitous
- [llama.cpp](https://github.com/ggml-org/llama.cpp) — Lightweight LLM inference
- [Claude Code](https://claude.ai/code) — Terminal-native agent UX, bubblewrap sandboxing
- [tmux](https://github.com/tmux/tmux) — Detachable terminal sessions that survive disconnects

### Related Projects

These projects solve overlapping problems with different trade-offs. Agnx differentiates by prioritizing portability (transparent file-based state), lightweight isolation (bubblewrap over Docker), and minimal footprint (single binary, no interpreter dependencies).

| Project | Approach | Trade-off vs Agnx |
|---------|----------|-------------------|
| [Agno](https://github.com/agno-agi/agno) | Python agent runtime | Requires Python runtime |
| [Dify](https://github.com/langgenius/dify) | Full agent platform | Heavier, more opinionated |
| [mcp-agent](https://github.com/lastmile-ai/mcp-agent) | MCP-native framework | Less focus on session durability |
| [OpenHands](https://github.com/OpenHands/OpenHands) | Docker sandboxes | Requires Docker |
| [E2B](https://e2b.dev/) | Cloud sandboxes | Cloud-only, no self-host |
