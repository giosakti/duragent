# Gateway Plugins

## What is this?

Platform gateway system enabling Agnx to communicate with messaging platforms (Telegram, WhatsApp, Discord). Supports both built-in gateways (compiled in) and external gateways (subprocess).

## The Problem

Agnx core provides CLI, HTTP, and SSE interfaces, but users want to interact with agents via messaging platforms. Each platform has different APIs, authentication flows, and message formats. We need a unified gateway architecture that's simple for self-hosters yet flexible for production deployments.

## User Scenarios

### Scenario 1: Self-host with Telegram

1. User installs `agnx` (default build includes Telegram)
2. User adds `TELEGRAM_BOT_TOKEN` to config
3. User runs `agnx serve` — Telegram bot starts automatically
4. Messages to the bot are routed to configured agent

### Scenario 2: Production with Crash Isolation

1. User builds `agnx --no-default-features` (minimal core)
2. User runs Telegram gateway as separate process
3. Gateway crashes don't affect Agnx core
4. Agnx restarts gateway automatically per restart policy

### Scenario 3: Custom Gateway

1. Developer writes gateway in Python/Go/Node
2. Gateway implements Gateway Protocol (JSON over stdio)
3. User configures external gateway in `agnx.yaml`
4. Agnx spawns and supervises the custom gateway

## Core Features

- **Gateway Protocol**: JSON-over-stdio communication between Agnx and gateways
- **Built-in Gateways**: Telegram (default), WhatsApp/Discord (optional features)
- **External Gateways**: Subprocess plugins in any language
- **Gateway Manager**: Unified interface abstracting built-in vs subprocess
- **Session Routing**: Gateway chats persist mapping to sessions across restarts
- **Process Supervision**: Restart policies, health checks, graceful shutdown

## Session Routing

Gateway chats are mapped to sessions and persisted in the session snapshot:

```yaml
# .agnx/sessions/{session_id}/snapshot.yaml
schema_version: 1
session_id: session_abc123
agent: my-agent
status: active
gateway: telegram           # Which gateway this session belongs to
gateway_chat_id: "123456"   # Platform-specific chat identifier
# ... rest of snapshot
```

On server restart:
1. Sessions are recovered from disk (existing behavior)
2. For each session with `gateway` + `gateway_chat_id`, rebuild the routing cache
3. Incoming gateway messages find existing sessions instead of creating new ones

This ensures conversation continuity across server restarts while keeping all state in human-readable session files (aligns with "transparent state" philosophy).

## Agent Routing

Global routing rules direct messages from any gateway to specific agents based on message context.

### Configuration

```yaml
gateways:
  telegram:
    enabled: true
    bot_token: ${TELEGRAM_BOT_TOKEN}

# Global routing rules (evaluated in order, first match wins)
routes:
  - match:
      gateway: "telegram"
      sender_id: "123456789"  # Route specific user to personal assistant
    agent: "personal-assistant"

  - match:
      gateway: "telegram"
      chat_id: "-1001234567890"  # Route specific group to work agent
    agent: "work-assistant"

  - match:
      chat_type: "group"  # Route all groups (any gateway) to moderator
    agent: "group-moderator"

  - match: {}  # Catch-all fallback
    agent: "general-assistant"
```

### Rules

- **Global scope**: Routes apply to all gateways; use `gateway` match to filter
- **Order matters**: Rules are evaluated top-to-bottom, first match wins
- **AND logic**: All conditions in `match` must be satisfied
- **Catch-all**: Use `match: {}` as last rule for fallback; if no rules match and no catch-all, uses first available agent

### Match Conditions

| Field | Description | Example Values |
|-------|-------------|----------------|
| `gateway` | Gateway name | `"telegram"`, `"discord"` |
| `chat_type` | Type of chat | `"dm"`, `"group"`, `"channel"` |
| `chat_id` | Platform-specific chat identifier | `"123456"`, `"-1001234567890"` |
| `sender_id` | Platform-specific user identifier | `"123456789"` |

All conditions are optional. An empty `match` block matches everything.

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    agnx (single binary)                          │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                  Gateway Manager                             │ │
│  │   Abstracts built-in (channels) vs external (JSON/stdio)    │ │
│  └──────────────────────────┬──────────────────────────────────┘ │
│                             │                                    │
│    ┌────────────────────────┼────────────────────────────────┐   │
│    │ Built-in (feature flags)                                │   │
│    │  [telegram]  [discord]  [whatsapp]                      │   │
│    └────────────────────────┼────────────────────────────────┘   │
│                             │                                    │
└─────────────────────────────┼────────────────────────────────────┘
                              │ JSON/stdio
                    ┌─────────┴─────────┐
                    │ External Gateways │
                    │ (any language)    │
                    └───────────────────┘
```

## Gateway Protocol (v1)

### Commands (Agnx → Gateway)

| Command | Purpose |
|---------|---------|
| `send_message` | Send text to chat |
| `send_media` | Send image/video/document |
| `send_typing` | Show typing indicator |
| `edit_message` | Edit sent message |
| `ping` | Health check |
| `shutdown` | Graceful termination |

### Events (Gateway → Agnx)

| Event | Purpose |
|-------|---------|
| `ready` | Gateway initialized, capabilities declared |
| `message_received` | Incoming user message |
| `command_ok` | Command succeeded |
| `command_error` | Command failed |
| `auth_required` | QR code needed (WhatsApp) |
| `shutdown` | Gateway terminating |

## Repo Structure

```
agnx/
├── Cargo.toml                    # Workspace root
└── crates/
    ├── agnx/                     # Main binary + library
    │   ├── Cargo.toml
    │   └── src/
    │       └── gateway/
    │           ├── mod.rs        # Re-exports from protocol crate
    │           ├── manager.rs    # Gateway lifecycle management
    │           ├── handler.rs    # Message routing to sessions
    │           └── subprocess.rs # Subprocess spawner/supervisor
    ├── agnx-gateway-protocol/    # Shared protocol types (for external devs)
    │   ├── Cargo.toml
    │   └── src/lib.rs
    └── agnx-gateway-telegram/    # Telegram gateway
        ├── Cargo.toml            # lib + bin targets
        └── src/
            ├── lib.rs            # Core logic (both modes)
            └── main.rs           # Subprocess entry point
```

Same gateway code compiles as library (built-in) or binary (subprocess).

## Acceptance Criteria

- [x] Gateway Protocol spec implemented in `agnx-gateway-protocol` crate
- [x] Gateway Manager handles both built-in and subprocess uniformly
- [x] Telegram gateway works in built-in mode (default feature)
- [x] Telegram gateway works as subprocess (same crate, binary target)
- [x] Subprocess gateways die when Agnx dies (no orphans via `prctl` + stdin EOF)
- [x] Subprocess restart policy configurable (on-failure, max attempts, backoff)
- [x] Feature flags control binary size (`--no-default-features` excludes gateways)
- [x] Gateway sessions persist across server restarts (routing stored in session snapshot)
- [x] Agent routing rules configurable (match by chat_type, chat_id, sender_id)

## Out of Scope

- WhatsApp gateway implementation (future milestone)
- Discord/Slack gateways (future milestone)
- Webhook mode for Telegram (long polling first)
- Gateway hot-reload without restart

## Technical Notes

- Use `prctl(PR_SET_PDEATHSIG)` on Linux for subprocess cleanup
- Cross-platform: detect stdin EOF as parent death signal
- Subprocess communication: JSON Lines (newline-delimited JSON) over stdio
- Built-in communication: Rust mpsc channels (no serialization)
