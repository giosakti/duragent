# Duragent Format Specification

## Overview

The Duragent Format defines a portable, human-readable specification for AI agents. It draws inspiration from:

- **[AGENTS.md](https://agents.md/)** — Simple markdown for coding agents (OpenAI/Linux Foundation)
- **[Claude Code Skills](https://code.claude.com/docs/en/skills)** — Skill.md with frontmatter and bundled resources
- **[Open Agent Specification](https://arxiv.org/abs/2510.04173v3)** — Declarative agent workflows (Oracle)
- **[A2A Protocol](https://a2a-protocol.org/)** — Agent Card for discovery (Google/Linux Foundation)
- **[Pi-mono/Clawdbot](https://docs.clawd.bot/concepts/agent)** — Bootstrap files pattern (AGENTS.md, SOUL.md, etc.)
- **Kubernetes manifests** — apiVersion/kind/metadata/spec pattern

## Design Principles

1. **Human-readable** — YAML/Markdown, editable in any text editor
2. **Portable** — Works across runtimes, not tied to Duragent
3. **Progressive** — Simple agents are simple; complex agents are possible
4. **Composable** — Skills, tools, and memory are modular
5. **Git-friendly** — Text files, easy to version and diff
6. **Context-efficient** — Minimal system prompts; load context on demand
7. **File-first storage** — Default to files for state; external backends for scale

## Deployment Context

Duragent Format agents are designed to work in two deployment modes:

### Self-Hosted (File-Based State)

For power users running Duragent locally, agents and runtime states are stored as files under `./.duragent/`.

In this mode we assume **a single local user**; `./.duragent/{memory,sessions,artifacts}` are user-owned stores (not nested under a specific agent). Sessions and artifacts may reference which agent produced them.

```
~/duragent-workspace/
└── ./.duragent/                           # File-based state root (portable)
    ├── agents/
    │   └── my-agent/
    │       ├── agent.yaml              # Agent definition
    │       ├── SOUL.md                 # Agent personality (optional)
    │       ├── SYSTEM_PROMPT.md        # Agent system prompt (optional)
    │       ├── INSTRUCTIONS.md         # Agent behavior instructions (optional)
    │       └── tools/                  # CLI tools for this agent
    │           └── my-tool.sh
    ├── sessions/                       # User sessions (reference agent + channel)
    │   └── session_abc/
    │       ├── events.jsonl            # Append-only event log
    │       └── state.yaml              # Snapshot for fast resume
    ├── memory/                         # User memory store (planned)
    └── artifacts/                      # User artifacts (planned)
```

**Benefits:**
- Everything is visible, editable, git-versioned
- No database setup required
- Agent + memory are portable as a single folder

**Note:** By convention, Duragent's file-based state root is `./.duragent/` (relative to the current working directory). For simple self-hosted usage, you typically run Duragent from a workspace directory and keep all durable state under `./.duragent/`.

### SaaS (External State)

For managed services, the agent definition is the same, but state is stored externally:

```yaml
services:
  session:   { backend: postgres, url: ${DATABASE_URL} }
  memory:    { backend: postgres, url: ${DATABASE_URL} }
  artifacts: { backend: s3, bucket: my-artifacts, region: us-east-1 }
```

**Benefits:**
- Multi-tenant scalability
- ACID guarantees
- Centralized backup/restore
- Same agent definition works in both modes

## Agent Definition

### Minimal Agent

```yaml
# agent.yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: simple-assistant
spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
  system_prompt: ./SYSTEM_PROMPT.md
```

### Full Agent

```yaml
# agent.yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: productivity-assistant
  description: Personal productivity assistant with task management
  version: 1.0.0
  labels:
    domain: productivity
    tier: premium

spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
    temperature: 0.7
    max_output_tokens: 4096

  # Agent personality and communication style (optional).
  soul: ./SOUL.md

  # Loaded into every turn of the conversation (optional).
  system_prompt: ./SYSTEM_PROMPT.md

  # Detailed behavioral rules/playbooks (optional).
  instructions: ./INSTRUCTIONS.md

  # Session behavior
  session:
    on_disconnect: continue       # or: pause (default)
    max_tool_iterations: 10       # default: 10
    ttl_hours: 48                 # per-agent TTL override (optional)
    compaction: archive           # per-agent compaction override (optional)
    # max_background_runtime: 30m # planned
    context:
      max_history_tokens: 20000   # default: 20000 (0 = no cap)
      max_tool_result_tokens: 8000 # default: 8000

  # Access control (optional, gateway-only)
  access:
    dm:
      policy: open                # open | disabled | allowlist
    groups:
      policy: allowlist           # open | disabled | allowlist
      allowlist: ["telegram:-100123456"]
      sender_default: silent       # allow | passive | silent | block
      sender_overrides:
        "67890": allow
        "99999": block
      activation: mention          # mention (default) | always
      context_buffer:
        mode: silent               # silent (default) | passive
        max_messages: 100
        max_age_hours: 24
      queue:
        mode: batch                # batch (default) | sequential | drop
        max_pending: 10
        overflow: drop_old         # drop_old (default) | drop_new | reject
        debounce:
          enabled: true
          window_ms: 1500

  # Memory (planned)
  # memory:
  #   short_term:
  #     backend: buffer
  #     max_tokens: 8000
  #   long_term:
  #     backend: filesystem

  tools:
    # Built-in tools
    - type: builtin
      name: bash                           # Execute shell commands

    # CLI tools (custom scripts)
    - type: cli
      name: git-helper
      command: ./tools/git-helper/script.sh
      description: Run git operations      # optional
      readme: ./tools/git-helper/README.md # optional

    # MCP tools (planned)
    - type: mcp
      name: web_search
      server: /usr/local/bin/web-search-mcp
    - type: mcp
      name: calendar
      server: ./tools/calendar-mcp
      config:
        calendar_id: primary

  # Skills (planned)
  # skills_dir: ./skills/
  # skills:
  #   - path: ../shared-skills/meeting-notes/
  #   - url: https://example.com/productivity/weekly-review

  # Triggers (planned - see scheduled-tasks spec)
  # triggers:
  #   - pattern: "extract tasks from *"
  #     skill: task-extraction
  #   - schedule: "0 20 * * FRI"
  #     skill: weekly-review
```

## Spec Fields Reference

### metadata

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Unique identifier (alphanumeric, hyphens) |
| `description` | string | No | Human-readable description |
| `version` | string | No | Semantic version |
| `labels` | map | No | Key-value labels for filtering (e.g. `domain: productivity`, `tier: premium`) |

### spec.model

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `provider` | string | Yes | LLM provider (openrouter, openai, anthropic, ollama) |
| `name` | string | Yes | Model name/identifier |
| `temperature` | float | No | Sampling temperature (0-2, default 0.7) |
| `max_input_tokens` | int | No | Optional hint for Duragent-side input truncation before calling the provider |
| `max_output_tokens` | int | No | Max response tokens (output/completion tokens) |
| `base_url` | string | No | Override model provider's base URL |

### spec.soul

Path to a markdown file defining the agent's personality and communication style. Injected into context alongside system_prompt.

**Example SOUL.md:**
```markdown
Communication style rules:
- Be concise and concrete; prefer bullet points over paragraphs
- Ask one clarifying question when requirements are ambiguous
- Avoid hype and filler; explain tradeoffs plainly
- Match the user's tone; only use emojis if the user uses them first
```

### spec.system_prompt

Path to a markdown file defining the agent's identity and role. Loaded into every turn of a session.

**Best practice:** Keep this minimal. Put detailed behavioral rules in `INSTRUCTIONS.md` and put large, situational context into skills/bootstrap files loaded only when needed.

### spec.instructions

Path to a markdown file defining detailed behavioral instructions (the agent's "playbook"): operating rules, policies, step-by-step workflows, output formats, and refusal boundaries.

Can reference:
- `${user.name}` — User's name (from context)
- `${user.timezone}` — User's timezone
- `${date}` — Current date
- `${time}` — Current time
- `${duragent.data_dir}` — Runtime data root (file-based mode uses `./.duragent/`)

### spec.bootstrap (Planned)

List of markdown files injected into context on first turn of a session.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `path` | string | Yes | Path to markdown file |
| `max_tokens` | int | No | Truncate if file exceeds limit |
| `required` | bool | No | Error if file missing (default false) |

**Note:** Currently, use `soul`, `system_prompt`, and `instructions` fields for agent context. The `bootstrap` field is planned for additional context files.

### spec.session

Session behavior configuration. Sessions follow tmux-like semantics: **disconnection does not stop the session**.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `on_disconnect` | string | No | Behavior when client disconnects: `continue` or `pause` (default: `pause`) |
| `max_tool_iterations` | int | No | Maximum tool call iterations per request (default: 10) |
| `ttl_hours` | int | No | Per-agent TTL override (hours). Overrides global `sessions.ttl_hours`. |
| `compaction` | string | No | Per-agent compaction mode override: `discard`, `archive`, `disabled`. Overrides global `sessions.compaction`. |
| `context` | object | No | Context window management settings (see `spec.session.context` below) |
| `max_background_runtime` | duration | No | Maximum time agent can run without client (planned) |
| `output_buffer_size` | int | No | Max events to buffer while disconnected (planned) |

**Disconnect modes:**

| Mode | Behavior | Use Case |
|------|----------|----------|
| `continue` | Agent keeps executing, buffers output | Async workflows, supervisor agents |
| `pause` | Agent pauses at next safe point, waits for reconnect | Interactive chat |

**Example — Interactive assistant (pauses on disconnect):**
```yaml
session:
  on_disconnect: pause
```

**Example — Autonomous supervisor (continues on disconnect):**
```yaml
session:
  on_disconnect: continue
  max_background_runtime: 2h
```

#### spec.session.context

Context window management configuration. Controls how conversation history and tool results are truncated to fit within the model's context window. All fields have sensible defaults — the entire `context` block can be omitted.

```yaml
session:
  context:
    max_history_tokens: 20000       # Cap history tokens to reserve budget for tool work (0 = no cap)
    max_tool_result_tokens: 8000    # Per-result token cap
    tool_result_truncation: head    # head, tail, or both
    tool_result_keep_first: 2       # First N tool results kept visible
    tool_result_keep_last: 5        # Last M tool results kept visible
```

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `max_history_tokens` | int | `20000` | Max tokens for conversation history in each LLM call. Reserves remaining budget for tool work during agentic loops. `0` = no cap. |
| `max_tool_result_tokens` | int | `8000` | Max tokens per individual tool result. Must be > 0. |
| `tool_result_truncation` | string | `head` | How to truncate oversized tool results: `head` (keep beginning), `tail` (keep end), or `both` (keep beginning + end, 50/50 split). |
| `tool_result_keep_first` | int | `2` | First N tool results kept visible during agentic loops (older results in the middle are masked). |
| `tool_result_keep_last` | int | `5` | Last M tool results kept visible during agentic loops. Both `0` = masking disabled. |

Token estimation uses a `bytes / 4` heuristic with a 10% safety margin. See the [Context Window Management spec](./202602081000.context-window-management.md) for the full three-layer truncation design.

### spec.access

Access control configuration. Controls who can interact with the agent via gateways (Telegram, Discord, etc.). Does not affect HTTP API or CLI access.

When omitted, the agent accepts all messages (open access).

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `dm` | object | No | DM (direct message) access policy |
| `groups` | object | No | Group/channel access policy |

**`dm` fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `policy` | string | `open` | `open` (accept all), `disabled` (reject all), or `allowlist` (sender IDs only) |
| `allowlist` | list | `[]` | Sender IDs allowed when policy is `allowlist`. Supports trailing `*` wildcards (e.g. `user_*`). |

**`groups` fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `policy` | string | `open` | `open` (accept all), `disabled` (reject all), or `allowlist` (composite keys only) |
| `allowlist` | list | `[]` | `{channel}:{chat_id}` composite keys allowed when policy is `allowlist` (e.g. `telegram:-100123456`, `discord:1234567890`). Supports trailing `*` wildcards (e.g. `telegram:*` for all Telegram groups, `*` for all groups). |
| `sender_default` | string | `allow` | Default sender disposition within allowed groups |
| `sender_overrides` | map | `{}` | Per-sender disposition overrides (sender ID → disposition). Supports trailing `*` wildcards (e.g. `admin_*`); exact matches take priority. |
| `activation` | string | `mention` | `mention` (respond only when @mentioned or replied to) or `always` (respond to every allowed message) |
| `context_buffer` | object | see below | Configuration for non-triggering messages in mention mode |
| `queue` | object | see below | Queue configuration for handling concurrent messages |

**Sender dispositions (groups only):**

| Disposition | LLM sees it? | Triggers response? | Stored in session? | Use case |
|-------------|-------------|-------------------|-------------------|----------|
| `allow` | Yes | Yes | Yes (UserMessage) | Normal interaction |
| `passive` | Yes (future turns) | No | Yes (UserMessage) | Context without triggering |
| `silent` | No | No | Yes (SilentMessage) | Audit trail only |
| `block` | No | No | No | Spam, bad actors |

Disposition resolution: check `sender_overrides` for exact sender ID match first, then wildcard pattern match, then fall back to `sender_default`.

**Activation modes:**

| Mode | Behavior |
|------|----------|
| `mention` | Only respond when @mentioned or replied to. Non-triggering messages from `allow` senders go to the context buffer. |
| `always` | Respond to every allowed message (no mention required). |

**`context_buffer` fields:**

Controls how non-triggering messages from `allow` senders are handled in `mention` mode.

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `mode` | string | `silent` | `silent` (ephemeral buffer, injected as system block on trigger) or `passive` (stored as UserMessage in conversation history) |
| `max_messages` | int | `100` | Maximum number of recent messages to inject (silent mode only) |
| `max_age_hours` | int | `24` | Maximum age in hours for buffer messages (silent mode only) |

**Context buffer modes:**

| Mode | Storage | LLM sees it? | Survives crash? | Token cost |
|------|---------|-------------|----------------|------------|
| `silent` | SilentMessage (ephemeral) | Only when triggered (injected as system block) | No | Low (only on trigger) |
| `passive` | UserMessage (conversation history) | Yes (every turn) | Yes | Accumulates over time |

**`queue` fields:**

Controls how concurrent messages are handled when the session is busy processing.

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `mode` | string | `batch` | `batch` (combine all pending into one), `sequential` (process one at a time), or `drop` (discard pending) |
| `max_pending` | int | `10` | Maximum number of messages waiting in the queue |
| `overflow` | string | `drop_old` | What happens when queue is full: `drop_old`, `drop_new`, or `reject` |
| `reject_message` | string | none | Message sent to the user when their message is rejected (only used with `reject` overflow) |
| `debounce` | object | see below | Per-sender debounce settings |

**Queue modes:**

| Mode | Behavior | Use case |
|------|----------|----------|
| `batch` | After processing completes, combine all pending messages into one and process it | Rapid message senders, group conversations |
| `sequential` | After processing completes, take the next pending message and process it (repeats until empty) | Preserve individual context per message |
| `drop` | After processing completes, discard all pending messages | Simple, predictable behavior |

**Overflow strategies:**

| Strategy | Behavior |
|----------|----------|
| `drop_old` | Evict the oldest pending message to make room for the new one |
| `drop_new` | Silently discard the new message |
| `reject` | Discard the new message and send `reject_message` back to the user |

**`debounce` fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `enabled` | bool | `true` | Whether per-sender debouncing is enabled |
| `window_ms` | int | `1500` | Idle window in milliseconds before flushing buffered messages |

**Example — Restricted agent with group sender control:**
```yaml
access:
  dm:
    policy: allowlist
    allowlist: ["12345"]
  groups:
    policy: allowlist
    allowlist: ["telegram:-100123456"]
    sender_default: passive
    sender_overrides:
      "67890": allow
      "99999": block
    activation: mention
    context_buffer:
      mode: silent
      max_messages: 50
      max_age_hours: 12
    queue:
      mode: sequential
      max_pending: 5
      overflow: reject
      reject_message: "I'm busy, please wait."
```

### spec.memory

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `short_term.backend` | string | No | buffer (default) or external |
| `short_term.max_tokens` | int | No | Token limit for in-context short-term memory |
| `long_term.backend` | string | No | filesystem (default) or external |

**Filesystem convention (file-based mode):**
- Use date-based Markdown files under `${duragent.data_dir}/memory/` (e.g. `YYYY-MM-DD.md`) for durable continuity notes.
- This keeps memory transparent, editable, and easy to export.

### spec.tools

List of tool definitions. Supports three types:

**Tool Types:**

| Type | Description | Status |
|------|-------------|--------|
| `builtin` | Built-in Duragent tools (e.g., `bash`) | ✅ Implemented |
| `cli` | CLI tool with optional README | ✅ Implemented |
| `mcp` | MCP server connection | Planned |

**MCP Tool Fields (Planned):**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | string | Yes | `mcp` |
| `name` | string | Yes | Tool identifier |
| `server` | string | Yes | MCP server command or path |
| `config` | map | No | Tool-specific configuration |

**Note on runtime dependencies:** Duragent itself aims to be a single binary (no Node/Python required). Some MCP servers are distributed as Node packages (often run via `npx`), but that is an optional tool choice rather than a requirement of Duragent core. Prefer pinned binaries/containers for portability.

**CLI Tool Fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | string | Yes | `cli` |
| `name` | string | Yes | Tool identifier |
| `command` | string | Yes | CLI command or script path (relative to agent dir) |
| `description` | string | No | Short description shown to LLM |
| `readme` | string | No | Path to README (agent reads on-demand) |

**Why CLI tools?**
- More token-efficient than MCP (no upfront schema dump)
- Agent reads README only when it needs the tool
- Simpler to create (just a script + README)
- Progressive disclosure pattern

**Built-in Tool Fields:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | string | Yes | `builtin` |
| `name` | string | Yes | Tool identifier (e.g., `bash`) |

**Available built-in tools:**

| Name | Description |
|------|-------------|
| `bash` | Execute shell commands in sandbox |

### spec.skills_dir

Directory containing local skills for this agent.

- Default: `./skills/` (relative to the agent directory)
- If set, Duragent will scan that directory for skill packages (each containing `SKILL.md`).

If a skill ID is needed (e.g. for `triggers.skill`), Duragent should derive it from:
- `SKILL.md` frontmatter `name` if present, otherwise
- the skill directory name.

### spec.skills

Optional additional skills to load, beyond whatever is discovered in `skills_dir`.

Each entry can point to:
- a local directory (`path`), or
- a remote skill package (`url`).

| Field | Type | Description |
|-------|------|-------------|
| `path` | string | Local path to a skill directory |
| `url` | string | Remote skill URL |

### spec.triggers

Automatic skill activation:

| Field | Type | Description |
|-------|------|-------------|
| `pattern` | string | Glob pattern to match user input |
| `schedule` | string | Cron expression for scheduled runs |
| `skill` | string | Skill ID to activate (from `skills_dir` and/or `skills`) |

## Skills

Skills are reusable behaviors that can be bundled with agents or shared independently.

### Real-World Skill Examples

| Skill | Purpose | Trigger |
|-------|---------|---------|
| `quick-note` | Capture a short note into a local file or notes app | "note: ...", "save this: ..." |
| `task-inbox` | Turn a message into actionable tasks and save them | "add a task ...", "remind me to ..." |
| `knowledge-search` | Search a personal knowledge base / docs folder | "search my notes for ...", "find docs about ..." |
| `draft-writer` | Produce a first draft with a specific structure/voice | "draft a post about ...", "write a memo for ..." |
| `weekly-review` | Summarize the week and propose next actions | Scheduled Fridays |
| `log-analyzer` | Inspect logs and return likely causes + next steps | "analyze logs for ...", "why did this fail?" |

**Key pattern:** Skills teach the agent how to use tools without writing code. Just drop a markdown file with instructions, triggers, and examples.

### Skill Directory Structure

```
skills/
└── task-extraction/
    ├── SKILL.md              # Required: Skill definition
    ├── scripts/
    │   └── extract.py        # Optional: Executable scripts
    ├── references/
    │   └── examples.md       # Optional: Loaded into context
    └── assets/
        └── template.txt      # Optional: Templates
```

### SKILL.md Format

Full example: `../examples/skills/task-extraction`

## A2A Agent Card (Discovery)

Duragent Format supports the [A2A Protocol](https://a2a-protocol.org/) Agent Card format for agent discovery. When an agent is deployed to Duragent, it automatically generates an A2A-compatible Agent Card.

### Auto-Generated Agent Card

Duragent generates an Agent Card from the Duragent Format definition:

```
GET /agents/{name}/.well-known/agent.json
```

**Example generated Agent Card:**

```json
{
  "name": "productivity-assistant",
  "description": "Personal productivity assistant with task management",
  "url": "https://duragent.example.com/agents/productivity-assistant",
  "version": "1.0.0",
  "protocolVersion": "0.3",
  "capabilities": {
    "streaming": true,
    "pushNotifications": false
  },
  "defaultInputModes": ["text"],
  "defaultOutputModes": ["text"],
  "skills": [
    {
      "id": "task-extraction",
      "name": "Task Extraction",
      "description": "Extract tasks from natural conversation",
      "inputModes": ["text"],
      "outputModes": ["text", "data"]
    },
    {
      "id": "meeting-notes",
      "name": "Meeting Notes",
      "description": "Generate structured meeting notes",
      "inputModes": ["text"],
      "outputModes": ["text"]
    }
  ],
  "securitySchemes": [
    {
      "type": "apiKey",
      "in": "header",
      "name": "Authorization"
    }
  ]
}
```

### Duragent Format to Agent Card Mapping

| Duragent Format Field | Agent Card Field |
|-----------|------------------|
| `metadata.name` | `name` |
| `metadata.description` | `description` |
| `metadata.version` | `version` |
| `skills_dir` + `skills[]` + `SKILL.md` frontmatter | `skills[].id`, `skills[].name`, `skills[].description` |
| `spec.tools` | `capabilities` (inferred) |

### Custom Agent Card Fields

For advanced A2A scenarios, you can extend the agent card in the Duragent Format:

```yaml
# agent.yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: my-agent
  a2a:
    defaultInputModes: [text, file]
    defaultOutputModes: [text, data]
    securitySchemes:
      - type: oauth2
        flows:
          authorizationCode:
            authorizationUrl: https://auth.example.com/authorize
            tokenUrl: https://auth.example.com/token
spec: {}
```

Duragent will still **serve the Agent Card as JSON** at `/.well-known/agent.json` because that's what A2A specifies.

### Use Cases for Agent Card

1. **Agent Discovery:** Orchestrators can query `/.well-known/agent.json` to find agent capabilities
2. **Multi-Agent Scenarios:** Agents can discover and delegate to other agents
3. **API Documentation:** Clients can understand what an agent can do before interacting
4. **Security Negotiation:** Clients discover required authentication methods

## Agent Package (Export Format)

For portability, agents can be exported as packages.

### Package Structure

```
my-agent.duragent/
├── agent.yaml                # Agent definition
├── SYSTEM_PROMPT.md          # Referenced by agent.yaml (recommended)
├── INSTRUCTIONS.md           # Referenced by agent.yaml (optional)
├── skills/                   # Bundled skills
│   └── task-extraction/
└── manifest.json             # Package metadata
```

### manifest.json

```json
{
  "format_version": "1.0",
  "exported_at": "2025-12-15T10:00:00Z",
  "duragent_version": "0.3.0",
  "agent": {
    "name": "productivity-assistant",
    "version": "1.0.0"
  },
  "includes": {
    "skills": true
  },
  "checksum": "sha256:abc123..."
}
```

### Export/Import Commands

```bash
# Export agent
duragent export --agent productivity-assistant --output ./export/

# Import agent
duragent import --file ./my-agent.duragent/
```

## Comparison with Other Formats

| Feature | Duragent Format | AGENTS.md | Claude Skills | Open Agent Spec | A2A Agent Card |
|---------|-----------------|-----------|---------------|-----------------|----------------|
| Format | YAML + MD | Markdown | MD + frontmatter | YAML/JSON | JSON |
| Agent definition | Yes | No (instructions only) | No (skills only) | Yes | No (discovery only) |
| Skills/behaviors | Yes | No | Yes | Partial | Metadata only |
| Memory config | Yes | No | No | Partial | No |
| Session config | Yes | No | No | No | No |
| Access control | Yes | No | No | No | No |
| Tool integration | MCP | N/A | N/A | Custom | N/A |
| Discovery | A2A Card | No | No | No | Yes |
| Export/import | Yes | No | No | Partial | No |
| Human-readable | Yes | Yes | Yes | Yes | Yes |

### Relationship to Standards

- **AGENTS.md compatibility:** Duragent Format's `instructions` field can reference AGENTS.md files
- **Claude Skills compatibility:** Duragent Format skills follow similar structure to Claude Skills
- **Open Agent Spec compatibility:** Duragent Format can be converted to/from OAS format
- **A2A compatibility:** Duragent Format auto-generates A2A Agent Cards for discovery
- **MCP compatibility:** Tools use MCP protocol natively

## Examples

### Example 1: Simple Q&A Bot

```yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: qa-bot
spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
  system_prompt: ./SYSTEM_PROMPT.md
```

### Example 2: Code Review Agent

```yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: code-reviewer
spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
    temperature: 0.3
  system_prompt: ./SYSTEM_PROMPT.md
  instructions: ./INSTRUCTIONS.md
  session:
    on_disconnect: pause  # Interactive review sessions
  tools:
    - type: builtin
      name: bash
    - type: cli
      name: git-diff
      command: ./tools/git-diff.sh
      description: Show git diff for review
```

### Example 3: Personal Assistant

```yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: personal-assistant
spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
  soul: ./SOUL.md
  system_prompt: ./SYSTEM_PROMPT.md
  instructions: ./INSTRUCTIONS.md
  session:
    on_disconnect: pause  # Interactive assistant
    max_tool_iterations: 15
  tools:
    - type: builtin
      name: bash
    - type: cli
      name: notes
      command: ./tools/notes.sh
      description: Manage personal notes
```

### Example 4: Autonomous Code Supervisor (Future)

```yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: code-supervisor
  description: Completes coding tasks autonomously
spec:
  model:
    provider: anthropic
    name: claude-sonnet-4-20250514
  system_prompt: ./SYSTEM_PROMPT.md
  session:
    on_disconnect: continue  # Keeps working after user disconnects
    max_tool_iterations: 50
  tools:
    - type: builtin
      name: bash
    - type: cli
      name: git-pr
      command: ./tools/git-pr.sh
      description: Create GitHub pull requests
```

## Versioning

The format uses semantic versioning-like API versions:
- `duragent/v1alpha1` — Alpha version (breaking changes allowed)
- `duragent/v1beta1` — Beta version (mostly stable; minor breakage still possible)
- `duragent/v1` — Stable version
- `duragent/v2` — Future breaking changes

Duragent runtime will support multiple versions and provide migration tools.

## References

### Standards
- [AGENTS.md Specification](https://agents.md/)
- [A2A Protocol Specification](https://a2a-protocol.org/) — Agent-to-Agent protocol (Linux Foundation)
- [Open Agent Specification](https://arxiv.org/abs/2510.04173v3)
- [Model Context Protocol](https://modelcontextprotocol.io/)
- [Agent Protocol](https://agentprotocol.ai/)

### Format Inspiration
- [Claude Code Skills](https://code.claude.com/docs/en/skills) — Skill.md format
- [Google ADK](https://google.github.io/adk-docs/) — Agent Development Kit
- [Pi-mono](https://github.com/badlogic/pi-mono) — Minimal agent toolkit
