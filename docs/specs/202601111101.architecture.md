# Duragent Architecture

This document describes Duragent's internal architecture, including the runtime, services, gateways, and sandbox systems.

## 1. Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Duragent                                       │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    Core Gateways (built-in)                       │  │
│  │        CLI/TUI  │  HTTP REST (API / Admin API) │  SSE             │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                 │                                       │
│                          Gateway Protocol                               │
│                         (JSON over stdio)                               │
│                                 │                                       │
│         ┌───────────────────────┼───────────────────────┐               │
│         ▼                       ▼                       ▼               │
│    [Telegram]              [Discord]               [others]             │
│     (plugin)                (plugin)               (plugin)             │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                       Agent Registry                              │  │
│  │  In-memory map of loaded agents (from files or API)               │  │
│  │  - Lazy loading with LRU cache                                    │  │
│  │  - Server: supports thousands of agents; Edge: optimized for few  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                 │                                       │
│                                 ▼                                       │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                          Runner                                   │  │
│  │  - Manages event loop                                             │  │
│  │  - Processes events from execution logic                          │  │
│  │  - Commits state via Services                                     │  │
│  │  - Streams responses to clients                                   │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│         │                │                │                │            │
│         ▼                ▼                ▼                ▼            │
│  ┌───────────┐    ┌───────────┐    ┌───────────┐    ┌───────────┐       │
│  │    LLM    │    │   Tools   │    │  Services │    │  Sandbox  │       │
│  │ Interface │    │   (MCP)   │    │ (Session, │    │ (bwrap,   │       │
│  │           │    │           │    │  Memory,  │    │  Docker)  │       │
│  │           │    │           │    │  Artifact)│    │           │       │
│  └───────────┘    └───────────┘    └───────────┘    └───────────┘       │
│         │                │                │                │            │
│         ▼                ▼                ▼                ▼            │
│  ┌───────────┐    ┌───────────┐    ┌───────────┐    ┌───────────┐       │
│  │ OpenRouter│    │MCP Server │    │ Filesystem│    │ bubblewrap│       │
│  │ OpenAI    │    │(external) │    │ (default) │    │ Docker    │       │
│  │ Anthropic │    │           │    │ Postgres  │    │           │       │
│  │ Ollama    │    │           │    │ S3        │    │           │       │
│  └───────────┘    └───────────┘    └───────────┘    └───────────┘       │
└─────────────────────────────────────────────────────────────────────────┘
```

## 2. Core Concepts

### Agent

An agent is defined by a YAML file with unstructured content (e.g. prompts, instructions) stored as Markdown files. See [Duragent Format](./202601111200.duragent-format.md) for the full specification.

### Session

A session is a persistent conversation context that survives crashes, restarts, and disconnects. Sessions can be accessed from any gateway (CLI, HTTP, Telegram, etc.).

### TaskList

A TaskList is a persistent collection of tasks that can be shared across sessions. Inspired by Claude Code's Tasks, TaskLists enable agents to:
- Track complex, multi-step projects
- Coordinate work across multiple sessions or subagents
- Persist progress across context windows

```yaml
# .duragent/tasks/auth-refactor.yaml
id: auth-refactor
created_at: 2025-01-24T10:00:00Z
sessions:
  - session_abc123
  - session_def456    # Multiple sessions can collaborate

tasks:
  - id: task_001
    content: Add JWT library
    status: completed
    completed_at: 2025-01-24T10:30:00Z

  - id: task_002
    content: Create auth middleware
    status: in_progress
    depends_on: [task_001]

  - id: task_003
    content: Write tests
    status: blocked
    depends_on: [task_002]
```

TaskLists are stored as files — humans can edit them directly, and changes are visible to agents on next read.

**Concurrent Access:** TaskLists use advisory file locking (`flock`) when multiple sessions access the same file. For conflicting concurrent updates, last-write-wins semantics apply.

### Memory

Memory persists across conversations:

```yaml
memory:
  # Short-term: recent conversation context
  short_term:
    backend: buffer
    max_tokens: 4000

  # Long-term: facts, preferences, learned information
  long_term:
    backend: filesystem     # Default, file-based (portable)
    path: ./.duragent/memory/   # Markdown files
    # backend: postgres     # External backend (optional)
```

## 3. Runtime Architecture (Event Loop Pattern)

Duragent uses a **simple event loop pattern** for execution.

### Core Agent Loop

```
User Message → LLM Call → Tool Calls? → Execute Tools → Feed Results → Repeat
                              │                              │
                              └── No tools ──────────────────┘
                                     │
                                     ▼
                              Return Response
```

This is intentionally minimal. No max step limits, no complex orchestration knobs. Complexity is added only when real use cases demand it.

However, Duragent is **safe by default**: the Runner enforces execution budgets (e.g. max wall time, token budget, tool-call budget) and supports cancellation to prevent runaway loops.

### Full Runtime Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Duragent Runtime                             │
│                                                                 │
│  User Input ───────► Runner ─────────────────► Services         │
│       │              (Event Processor)         (pluggable)      │
│       │                   │                        │            │
│       │              Event Loop              ┌─────┴─────┐      │
│       │              (Ask/Yield)             │           │      │
│       │                   │            SessionService    │      │
│       │                   ▼            MemoryService     │      │
│       │            Execution Logic     ArtifactService   │      │
│       │            (Agent, LLM,              │           │      │
│       │             Tools, Callbacks)        ▼           │      │
│       │                   │              Storage         │      │
│       ◄───────────────────┘              (Filesystem,    │      │
│      Stream<Event>                        External)      │      │
└─────────────────────────────────────────────────────────────────┘
```

### Key Components

| Component | Description |
|-----------|-------------|
| **Runner** | Orchestrator that manages event loop, receives queries, processes events |
| **Event Loop** | Ask/Yield pattern between Runner and Execution Logic |
| **Execution Logic** | Agents, LLM calls, tools, callbacks |
| **Services** | Pluggable backends for session, memory, artifacts |
| **Events** | Messages carrying content + details (separated for LLM vs UI) |

### Event Loop Flow

1. Runner receives user query, updates session history
2. Runner asks Execution Logic (agent) to process
3. Agent yields events (partial responses, tool calls, state changes)
4. Runner processes each event (commits state, streams to client)
5. Runner signals agent to resume
6. Repeat until agent yields final event

### Tool Result Structure

```rust
pub struct ToolResult {
    pub content: String,           // For LLM consumption
    pub details: serde_json::Value, // For UI/client rendering
    pub error: Option<String>,
}
```

**Benefits:**
- Streaming LLM responses with partial events
- State changes guaranteed committed before execution resumes
- Tool execution with proper side-effect handling
- Graceful cancellation support
- Clear separation of LLM content vs UI metadata

## 4. Gateway Architecture

Gateways handle communication between users and agents. Duragent separates **core protocols** (built-in) from **platform integrations** (plugins).

### Core Gateways (Built-in)

These are integration protocols that ship with Duragent:

| Gateway | Use Case | Library |
|---------|----------|---------|
| **CLI/TUI** | Local development, `duragent chat`, `duragent attach` | clap + ratatui |
| **HTTP REST** | Programmatic access, webhooks | axum |
| **SSE** | LLM token streaming | axum |

### Platform Gateways (Plugins)

Platform-specific integrations (Telegram, Discord, etc) run as separate processes communicating via the **Gateway Protocol** (JSON over stdio). This keeps Duragent core minimal while allowing any platform integration.

```
┌─────────────────────────────────────────────────────────────┐
│                         Duragent                                │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              Core Gateways (built-in)               │    │
│  │       CLI/TUI │ HTTP REST │ SSE                     │    │
│  └─────────────────────────────────────────────────────┘    │
│                           │                                 │
│                    Gateway Protocol                         │
│                    (stdin/stdout JSON)                      │
│                           │                                 │
└───────────────────────────┼─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
   ┌─────────┐        ┌──────────┐        ┌─────────┐
   │Telegram │        │ Discord  │        │ others  │
   │ Gateway │        │ Gateway  │        │ Gateway │
   │(subprocess)      │(subprocess)       │(subprocess)
   └─────────┘        └──────────┘        └─────────┘
```

### Gateway Protocol

The protocol uses JSON messages over stdio (similar to MCP):

```rust
// Duragent → Gateway (stdout of gateway process)
enum ToGateway {
    SendMessage { chat_id: String, content: String, stream: bool },
    SendMedia { chat_id: String, media: Media },
    Typing { chat_id: String, active: bool },
}

// Gateway → Duragent (stdin of gateway process)
enum FromGateway {
    MessageReceived { chat_id: String, user_id: String, content: String },
    MediaReceived { chat_id: String, user_id: String, media: Media },
    Error { code: String, message: String },
}
```

### Why This Architecture?

| Concern | Core Gateways | Plugin Gateways |
|---------|---------------|-----------------|
| Performance | Native Rust, zero overhead | Subprocess IPC overhead |
| Isolation | In-process | Crash independently |
| Language | Rust only | Any language |
| Release cycle | Tied to Duragent | Independent |
| Complexity | Protocol-level | Platform-specific |

**Note on Runtime Dependencies:** First-party gateway plugins (Telegram, Discord) are written in Rust and ship as standalone binaries. Third-party plugins may use any language; users deploying such plugins are responsible for their runtime requirements.

**Plugin Discovery:** Gateway plugins are discovered exclusively via the `gateways.external` configuration in `duragent.yaml`. There is no implicit path scanning or auto-discovery; all plugins must be explicitly configured.

This follows the precedent set by:
- **MCP**: JSON over stdio for tool integration
- **Terraform**: Provider plugins as separate binaries
- **Telegraf**: Input/output plugins as subprocesses

## 5. Sessions & State

Sessions are the core durability primitive in Duragent. A session is a persistent conversation context that survives crashes, restarts, and disconnects.

### Why Sessions Matter

| Without sessions | With sessions |
|------------------|---------------|
| Crash = context lost | Crash = reconnect and continue |
| One client only | Access from CLI, HTTP, Telegram, web |
| Tied to terminal | Portable across devices |
| No history API | Query conversation history programmatically |

### Session States

| State | Description |
|-------|-------------|
| `active` | Running, client connected |
| `running` | Running, client disconnected (continue mode) |
| `paused` | Waiting for reconnect (pause mode) |
| `ended` | Completed or explicitly ended |

### Disconnect Behavior

When a client disconnects, the agent's behavior is configurable:

| Mode | Behavior | Use Case |
|------|----------|----------|
| `continue` | Agent keeps executing, buffers output | Async workflows, fire-and-forget tasks |
| `pause` | Agent pauses, waits for reconnect | Interactive chat |

### Session Lifecycle

```
                    ┌─────────────────────────────────────────┐
                    │           Duragent Runtime                  │
                    │  ┌───────────────────────────────────┐  │
   CLI ────────────►│  │ Session: my-session               │  │◄──── HTTP API
                    │  │ State: events.jsonl + state.yaml  │  │
   Telegram ───────►│  │ Agent: my-assistant               │  │◄──── Web UI
                    │  └───────────────────────────────────┘  │
                    └─────────────────────────────────────────┘
```

Sessions are accessible from any gateway — the same session can be started from CLI, continued via Telegram, and queried via HTTP API.

### Services Layer

Services handle stateful operations with pluggable backends:

| Service | Purpose | Default Backend |
|---------|---------|-----------------|
| **SessionService** | Conversation threads, message history | Filesystem |
| **MemoryService** | Long-term knowledge, facts | Filesystem |
| **TaskService** | Task lists, dependencies, cross-session coordination | Filesystem |
| **ArtifactService** | Files, generated outputs | Filesystem |

All services implement a common interface:

```rust
#[async_trait]
pub trait StateBackend: Send + Sync {
    async fn get(&self, key: &str) -> Result<Option<Vec<u8>>>;
    async fn set(&self, key: &str, value: &[u8]) -> Result<()>;
    async fn delete(&self, key: &str) -> Result<()>;
    async fn list(&self, prefix: &str) -> Result<Vec<String>>;
}
```

This allows the same agent to run with filesystem (default), PostgreSQL, Redis, or S3 — just by changing configuration.

### Storage

Different file formats serve different purposes:

| Format | Use Case | Rationale |
|--------|----------|-----------|
| **JSONL** | Event streams (append-only) | Fast writes, no locking, human-readable |
| **YAML** | Structured state (snapshots, tasks) | Human-readable, git-friendly |
| **Markdown** | Prose content (prompts, memory) | Human-writable, natural for text |

**Directory structure:**

```
.duragent/
├── sessions/
│   └── {session_id}/
│       ├── events.jsonl      # Append-only event log
│       └── state.yaml        # Periodic snapshot (for fast resume)
├── schedules/
│   ├── {schedule_id}.yaml    # Schedule definition
│   └── runs/
│       └── {schedule_id}.jsonl  # Run history (JSONL)
├── memory/
│   └── 2025-01-24.md         # Daily memory (Markdown)
├── tasks/
│   └── auth-refactor.yaml    # TaskList (YAML)
└── artifacts/
    └── generated.txt         # Agent-generated files
```

**events.jsonl** (append-only, high-frequency writes):
```jsonl
{"ts":"2025-01-23T10:00:00Z","seq":1,"type":"msg","role":"user","content":"..."}
{"ts":"2025-01-23T10:00:05Z","seq":2,"type":"msg","role":"assistant","content":"..."}
{"ts":"2025-01-23T10:01:00Z","seq":3,"type":"tool","name":"read_file","status":"ok"}
```

**state.yaml** (periodic snapshot, fast reads):
```yaml
id: session_abc123
agent: my-assistant
status: active
created_at: 2025-01-23T10:00:00Z
last_event_seq: 42

messages:
  - role: user
    content: Help me refactor the auth module.
  - role: assistant
    content: I'll examine the current structure...
```

### Write/Read Paths

**Write path:**
1. Append event to `events.jsonl` (fast, lock-free)
2. Every N events or on detach: rebuild `state.yaml` snapshot
3. Snapshots are written atomically (write to temp file, then `rename()`) to prevent corruption on crash
4. Use advisory file locking (`flock`) for concurrent access edge cases

**Read path (resume):**
1. Load `state.yaml` (fast, complete state)
2. Replay any events after `last_event_seq` (usually none or few)

This hybrid approach gives: fast writes (append-only), fast reads (snapshot), human-readable state, and crash recovery.

### Session Compaction

To prevent unbounded growth of `events.jsonl`, Duragent applies automatic compaction:

```yaml
# duragent.yaml
session:
  compaction:
    trigger: 1000           # Compact after N events
    keep_messages: 100      # Keep last N messages in snapshot
    archive: true           # Archive old events to .archive/
```

**Compaction process:**
1. When `events.jsonl` exceeds `trigger` events, compaction runs
2. Recent messages (last `keep_messages`) are preserved in `state.yaml`
3. Old events are moved to `.archive/{session_id}/{timestamp}.jsonl`
4. `events.jsonl` is truncated to only events after the snapshot

This prevents storage bloat while maintaining full audit trail in archives.

### CLI Convenience

For terminal users, `duragent attach` provides a convenient way to connect to sessions:

```bash
duragent sessions                           # List sessions
duragent chat --agent my-assistant          # Start new session
duragent attach session_abc123              # Reconnect to existing session
```

For persistent terminal sessions, standard tools like tmux or zellij work alongside Duragent.

## 6. Sandbox Architecture

Agents execute commands in an isolated sandbox environment. The sandbox provides filesystem and network isolation while remaining lightweight.

### Sandbox Interface

```rust
/// Default timeout for command execution (2 minutes).
pub const DEFAULT_EXEC_TIMEOUT: Duration = Duration::from_secs(120);

#[async_trait]
pub trait Sandbox: Send + Sync {
    /// Execute a command in the sandbox with optional timeout.
    /// If `timeout` is `None`, uses `DEFAULT_EXEC_TIMEOUT`.
    async fn exec(
        &self,
        cmd: &str,
        args: &[String],
        cwd: Option<&Path>,
        timeout: Option<Duration>,
    ) -> Result<ExecResult, SandboxError>;

    /// Get the sandbox mode name (e.g., "trust", "bubblewrap", "docker").
    fn mode(&self) -> &'static str;
}

pub struct ExecResult {
    pub exit_code: i32,
    pub stdout: String,
    pub stderr: String,
}
```

**Future extensions** (not yet implemented):
- `capabilities()` — Query sandbox capabilities (filesystem/network isolation)
- `pause()` / `resume()` — Hibernate sandbox for session persistence
- `destroy()` — Clean up sandbox resources

### Sandbox Backends

| Backend | Platform | Overhead | Use Case |
|---------|----------|----------|----------|
| **None (trust mode)** | All | Zero | Local development, trusted environments |
| **bubblewrap** | Linux/WSL2 | ~50KB | Default for Linux, no daemon needed |
| **Docker** | All | Heavy | Stronger isolation, cross-platform fallback |

### Default Selection

```
Platform detection:
  Linux/WSL2  → bubblewrap (if available) → Docker → trust mode
  macOS       → Docker → trust mode
  Windows     → Docker → trust mode
```

### Isolation Layers

Following the same pattern as Claude Code's sandbox:

1. **Filesystem Isolation**
   - Write access: workspace directory only
   - Read access: configurable (default: workspace + system libraries)
   - Blocked: system files, other users' data

2. **Network Isolation** (optional)
   - Proxy-based domain filtering
   - Allowlist of permitted domains
   - Blocks exfiltration to unapproved hosts

3. **Process Isolation**
   - Agent can't see/kill other processes
   - Resource limits (CPU, memory) configurable

### bubblewrap Example

```bash
bwrap \
  --ro-bind /usr /usr \
  --ro-bind /lib /lib \
  --ro-bind /lib64 /lib64 \
  --symlink usr/bin /bin \
  --proc /proc \
  --dev /dev \
  --bind "$WORKSPACE" "$WORKSPACE" \
  --chdir "$WORKSPACE" \
  --unshare-all \
  --share-net \              # or --unshare-net for network isolation
  --die-with-parent \
  -- /bin/bash -c "$COMMAND"
```

### Sandbox Configuration

```yaml
# duragent.yaml
sandbox:
  backend: auto              # auto, bubblewrap, docker, none
  workspace: ./workspace     # Directory the agent can write to

  # Network isolation (optional)
  network:
    enabled: false           # Disable for local LLMs, enable for untrusted
    allowed_domains:
      - api.openai.com
      - api.anthropic.com
      - "*.githubusercontent.com"

  # Backend-specific config
  docker:
    image: "duragent/sandbox:latest"
```

### Sandbox + Session Integration

When a session detaches, the sandbox can be paused:

```
User detaches
      │
      ▼
┌─────────────────┐
│ sandbox.pause() │  ← Freeze sandbox state
└─────────────────┘
      │
      ▼
Session persisted to disk
      │
      ... hours later ...
      │
      ▼
User reattaches
      │
      ▼
┌──────────────────┐
│ sandbox.resume() │  ← Restore sandbox state
└──────────────────┘
```

## 7. Agent Orchestration

Duragent can orchestrate external coding agents (Claude Code, OpenCode, Aider). A **supervisor agent** running on Duragent delegates tasks to specialized **worker agents** and reviews their output.

### Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Duragent                                       │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    Supervisor Agent                               │  │
│  │                                                                   │  │
│  │  1. Receive task from user (async, e.g., via API/webhook)         │  │
│  │  2. Break down into subtasks                                      │  │
│  │  3. Delegate to worker agent (Claude Code headless)               │  │
│  │  4. Review worker output (LLM-based review)                       │  │
│  │  5. Approve / Request changes / Retry                             │  │
│  │  6. Notify user when complete                                     │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│         │                                                               │
│         │ subprocess / SDK                                              │
│         ▼                                                               │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                Worker Agents (external tools)                     │  │
│  │                                                                   │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │  │
│  │  │ Claude Code │  │  OpenCode   │  │   Aider     │                │  │
│  │  │ (headless)  │  │ (headless)  │  │ (headless)  │                │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘                │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│         │                                                               │
│         ▼                                                               │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                   Sandbox (bubblewrap/Docker)                     │  │
│  │              Workers execute in isolated environment              │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### Worker Agent Interfaces

#### Claude Code (Headless Mode)

Claude Code supports programmatic execution via the `-p` flag:

```bash
claude -p "Implement JWT authentication" \
  --output-format json \
  --allowedTools "Bash,Read,Edit,Write" \
  --resume "$SESSION_ID"
```

**Response:**
```json
{
  "result": "I've implemented JWT authentication...",
  "session_id": "abc123",
  "usage": { "input_tokens": 1500, "output_tokens": 800 }
}
```

#### OpenCode

OpenCode has a client/server architecture that can be driven programmatically:

```bash
opencode --headless --output json "Fix the failing tests"
```

### Built-in Orchestration Tools

Duragent provides built-in tools for invoking worker agents:

```rust
// Built-in tool: claude_code_exec
pub async fn claude_code_exec(
    prompt: &str,
    allowed_tools: &[&str],
    session_id: Option<&str>,
    sandbox: &dyn Sandbox,
) -> Result<WorkerResult>;

// Built-in tool: opencode_exec
pub async fn opencode_exec(
    prompt: &str,
    sandbox: &dyn Sandbox,
) -> Result<WorkerResult>;

// Built-in tool: notify_user
pub async fn notify_user(
    message: &str,
    channel: NotifyChannel,  // Slack, Email, Webhook
) -> Result<()>;
```

### Supervisor Agent Example

```yaml
# agents/code-supervisor/agent.yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: code-supervisor
  description: Supervises Claude Code to complete coding tasks autonomously

spec:
  model:
    provider: anthropic
    name: claude-sonnet-4-20250514

  system_prompt: ./system.md

  session:
    on_disconnect: continue
    max_background_runtime: 2h

  tools:
    - name: claude_code_exec
      type: builtin
    - name: opencode_exec
      type: builtin
    - name: notify_user
      type: builtin
    - name: task_list
      type: builtin
    - name: task_create
      type: builtin
    - name: task_complete
      type: builtin
    - name: github
      type: mcp
      server: /usr/local/bin/github-mcp
```

### User Flow

```
User (async, on phone):
  "Implement user authentication with JWT.
   Review carefully and create a PR when done."
         │
         ▼
┌─────────────────────────────────────────────────────────────────┐
│  Duragent Supervisor Agent (always running)                         │
│                                                                 │
│  1. Breaks down task:                                           │
│     - Add JWT library                                           │
│     - Create auth middleware                                    │
│     - Add login/logout endpoints                                │
│     - Write tests                                               │
│                                                                 │
│  2. For each subtask:                                           │
│     └─► claude_code_exec("Add JWT library", ["Bash","Edit"])    │
│         └─► Reviews output: "✓ Looks good"                      │
│     └─► claude_code_exec("Create auth middleware", ...)         │
│         └─► Reviews output: "✗ Missing error handling"          │
│         └─► claude_code_exec("Add error handling to...", ...)   │
│         └─► Reviews output: "✓ Fixed"                           │
│     └─► ... continues ...                                       │
│                                                                 │
│  3. Runs tests: "All 12 tests passing"                          │
│                                                                 │
│  4. Creates PR: #123                                            │
│                                                                 │
│  5. notify_user("Auth feature complete. PR: #123", slack)       │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
User receives Slack notification:
  "✅ Auth feature complete. PR created: github.com/repo/pull/123"
```

### Worker Session Management

The supervisor tracks worker sessions to enable:
- **Resume on failure**: If Claude Code crashes, resume from last checkpoint
- **Context continuity**: Multi-turn conversations with workers
- **Audit trail**: Full log of all worker invocations and outputs

```yaml
# .duragent/sessions/{supervisor_session}/workers.yaml
workers:
  - worker_type: claude_code
    session_id: "cc_abc123"
    subtask: "Add JWT library"
    status: completed

  - worker_type: claude_code
    session_id: "cc_def456"
    subtask: "Create auth middleware"
    status: completed
    attempts: 2  # Required retry
```

### Benefits of Orchestration Model

| Benefit | Description |
|---------|-------------|
| **Async operation** | User doesn't need to watch terminal |
| **Review loop** | Supervisor catches issues before merging |
| **Tool specialization** | Use best tool for each subtask |
| **Resilience** | Retry failures, resume from checkpoints |
| **Audit trail** | Full history of what happened |
| **Sandboxed** | Workers run in isolated environments |

## 8. Agent Loading & Tools

### Loading Modes

Duragent supports two agent loading modes:

| Mode | Use Case | Source |
|------|----------|--------|
| **Static** | GitOps, version-controlled agents | Files in `.duragent/agents/` |
| **Dynamic** | API-deployed, multi-tenant | Admin API or dynamic path |

Duragent uses lazy loading with an LRU cache. Server deployments can handle thousands of agents; edge deployments prioritize efficiency for a smaller number of agents.

### Agent Routing

When a message arrives from a gateway, Duragent determines which agent handles it via a **routing table**. Routes are evaluated in order; first match wins.

```yaml
# duragent.yaml
routes:
  # VIP user gets dedicated agent
  - agent: vip-support
    match:
      channel: telegram
      type: dm
      from: "123456789"

  # All Telegram DMs go to support bot
  - agent: support-bot
    match:
      channel: telegram
      type: dm

  # Specific WhatsApp group
  - agent: project-assistant
    match:
      channel: whatsapp
      conversation: "group-xyz"

  # Specific Slack channel
  - agent: eng-bot
    match:
      channel: slack
      workspace: "T12345"
      conversation: "#engineering"

  # Fallback (no match = catch-all)
  - agent: default
```

**Common match fields:**

| Field | Description | Examples |
|-------|-------------|----------|
| `channel` | Platform/gateway | `telegram`, `discord`, `slack`, `whatsapp` |
| `type` | Conversation type | `dm`, `group`, `channel`, `thread` |
| `conversation` | Specific group/channel ID | WA group ID, Slack channel |
| `from` | Sender user ID | User ID, phone number |
| `workspace` / `server` | Platform container | Slack workspace, Discord server |

Gateway plugins may expose additional fields (e.g., `thread`, `topic`). Any field the gateway provides can be matched.

**Routing rules:**
- Routes are evaluated top-to-bottom; first match wins
- Place more specific rules before general ones
- A route with no `match` clause (or empty match) acts as catch-all
- No implicit hierarchy — you control specificity via ordering

### Tools

Agents can use tools via three mechanisms:

| Type | How It Works | Best For |
|------|--------------|----------|
| **Built-in** | Bundled with Duragent | Core operations |
| **CLI** | Agent calls command, reads README for usage | Simple scripts, quick extensions |
| **MCP** | Type-safe protocol, schema exchange | Complex integrations, ecosystem tools |

**Built-in tools:**

| Tool | Purpose | Status |
|------|---------|--------|
| `bash` | Execute shell commands in sandbox | ✅ Implemented |
| `schedule_task` | Create scheduled task (one-shot, interval, cron) | ✅ Implemented |
| `list_schedules` | List active schedules for the agent | ✅ Implemented |
| `cancel_schedule` | Cancel an active schedule by ID | ✅ Implemented |
| `task_list` | View current tasks in a TaskList | Planned |
| `task_create` | Create task with optional dependencies | Planned |
| `task_update` | Update status, add notes | Planned |
| `task_complete` | Mark task as done | Planned |
| `claude_code_exec` | Invoke Claude Code in headless mode | Planned |
| `opencode_exec` | Invoke OpenCode in headless mode | Planned |
| `notify_user` | Send notification (Slack, email, webhook) | Planned |

**CLI tools:**
- Agent reads README on-demand, calls command directly
- More token-efficient (no upfront schema)
- Simpler to create (just a script + README)
- Any language, any runtime

**MCP tools:**
- Type-safe tool definitions with schemas
- Streaming support
- Large ecosystem of pre-built servers
- Protocol overhead (schema exchange upfront)

### Skills

Skills are separate from tools — they're reusable *behaviors* that teach the agent how to accomplish tasks.

| Concept | Purpose | Format |
|---------|---------|--------|
| **Tool** | A capability the agent can invoke | MCP server, CLI command, or built-in |
| **Skill** | Instructions for how to accomplish a task | SKILL.md with steps, triggers, examples |

Skills may *use* tools, but they're primarily about teaching patterns:
```
skills/
└── task-extraction/
    ├── SKILL.md              # Instructions: how to extract tasks
    └── references/
        └── examples.md       # Example inputs/outputs
```

### Tool Configuration
```yaml
# agent.yaml
tools:
  # Built-in tools (bundled with Duragent)
  - type: builtin
    name: bash                           # Execute shell commands

  # CLI tools (custom scripts)
  - type: cli
    name: git-helper                     # Tool name for LLM
    command: ./tools/git-helper.sh       # Relative to agent directory
    description: Run git operations      # Optional, shown to LLM
    readme: ./tools/git-helper/README.md # Optional, loaded on-demand

  # MCP tools (future)
  - type: mcp
    name: github
    server: /usr/local/bin/github-mcp
```

**Tool execution:**
- All tools execute with `agent_dir` (the directory containing `agent.yaml`) as the working directory
- CLI tool commands and README paths are resolved relative to `agent_dir`
- Sandbox timeout defaults to 2 minutes (`DEFAULT_EXEC_TIMEOUT`), configurable per-call

### Tool Approval Workflow

For dangerous operations (shell commands, file writes, external API calls), Duragent supports an approval workflow:

```yaml
# duragent.yaml
tools:
  approval:
    # Tools requiring explicit approval
    require_approval:
      - claude_code_exec
      - bash_exec
    # Auto-approve after N successful uses (trust building)
    auto_approve_after: 5
    # Timeout for approval requests
    timeout: 5m
```

**Approval flow:**
1. Agent requests tool invocation
2. Runner checks if tool requires approval
3. If yes, emits `approval_required` event to client
4. Client displays prompt; user approves/denies
5. On approval, tool executes; on deny, agent receives denial message
6. Approved tools can be auto-approved for future calls (configurable)

This balances autonomy (supervisor agents can work unattended) with safety (user retains control over dangerous operations).

### Scheduled Tasks

Agents can create time-based triggers via built-in schedule tools. Schedules persist across restarts and deliver results via any gateway.

**Timing options:**

| Type | Description | Example |
|------|-------------|---------|
| One-shot (`at`) | Fire once at specific time | `2026-02-01T09:00:00Z` |
| Interval (`every`) | Repeat every N seconds | `3600` (hourly) |
| Cron | Standard cron expression | `0 9 * * MON-FRI` (9am weekdays) |

**Payload types:**

| Type | Description |
|------|-------------|
| `message` | Send text directly (no LLM call) |
| `task` | Execute with agent tools, summarize results |

**Storage:**
```
.duragent/
├── schedules/
│   ├── sched_01HQXYZ.yaml    # Schedule definition
│   └── runs/
│       └── sched_01HQXYZ.jsonl  # Run history (JSONL)
```

**Session integration:** Scheduled tasks use a shared `ChatSessionCache` to find or create sessions. This ensures task results appear in the same conversation as user messages, enabling natural follow-up.

**Retry:** Schedules support optional retry with exponential backoff and jitter for transient failures (e.g., LLM provider 503).

## 9. Observability

Duragent provides structured observability from day one.

### Logging

All logs are structured JSON (via `tracing` crate):

```json
{"ts":"2025-01-24T10:00:00Z","level":"info","target":"duragent::runner","session_id":"abc123","agent":"my-assistant","message":"tool_invoked","tool":"read_file"}
```

**Log configuration:**
```yaml
# duragent.yaml
logging:
  level: info              # trace, debug, info, warn, error
  format: json             # json, pretty
  file: ./.duragent/duragent.log   # Optional file output
```

### Metrics (Future)

OpenTelemetry-compatible metrics for production deployments:

| Metric | Type | Description |
|--------|------|-------------|
| `duragent_sessions_active` | Gauge | Currently active sessions |
| `duragent_messages_total` | Counter | Total messages processed |
| `duragent_tool_calls_total` | Counter | Tool invocations by tool name |
| `duragent_llm_tokens_total` | Counter | Tokens used (input/output) |
| `duragent_llm_latency_seconds` | Histogram | LLM response latency |

### Tracing (Future)

Distributed tracing for multi-agent workflows:
- Trace ID propagated across supervisor → worker calls
- Spans for: message receive, LLM call, tool execution, response send
- Export to Jaeger, Zipkin, or OTLP-compatible backends

## 10. Standards Alignment

| Standard | How Duragent Aligns |
|----------|------------------|
| **[A2A Protocol](https://a2a-protocol.org/)** | Agent Card for discovery |
| **[MCP](https://modelcontextprotocol.io/)** | Tools integrate via MCP protocol |
| **[AGENTS.md](https://agents.md/)** | Supports AGENTS.md for repository context |

### A2A Agent Card Support

Duragent agents can expose an [A2A Agent Card](https://a2a-protocol.org/latest/specification/) for discovery:

```
GET /agents/{name}/.well-known/agent.json
```

The Agent Card is auto-generated from the agent definition, providing:
- Agent identity and description
- Supported capabilities (streaming, tools, memory)
- Skills as A2A "skills" with input/output modes
- Security requirements

## 11. Tech Stack

| Component | Choice | Rationale |
|-----------|--------|-----------|
| **Language** | Rust | Fast, compact binaries (~10-15MB), single-binary deployment, ARM support |
| **HTTP** | axum | Async, performant, SSE support |
| **CLI** | clap | Standard Rust CLI library |
| **TUI** | ratatui | Modern, well-maintained terminal UI |
| **Config** | YAML + Markdown | Structured config + human-readable prompts |
| **Serialization** | serde | De facto Rust standard |
| **State store** | Filesystem (default) | Zero dependencies, portable |
| **LLM Client** | reqwest | No heavy SDK dependencies |
| **MCP Client** | Custom | Direct protocol implementation |

## 12. Directory Structure

```
duragent/
├── src/
│   ├── main.rs                  # CLI entrypoint
│   ├── config.rs                # Load duragent.yaml, apply defaults
│   ├── build_info.rs            # Build metadata
│   ├── response.rs              # Response types
│   ├── handlers/                # HTTP handlers
│   │   ├── mod.rs
│   │   ├── health.rs
│   │   ├── version.rs
│   │   └── agents.rs
│   ├── gateway/                 # Gateway module
│   │   ├── mod.rs
│   │   ├── protocol.rs          # Gateway Protocol types
│   │   ├── core/                # Built-in gateways
│   │   │   ├── cli.rs
│   │   │   ├── http.rs
│   │   │   └── sse.rs
│   │   └── plugin.rs            # External gateway manager
│   ├── runtime/                 # Runtime module
│   │   ├── mod.rs
│   │   ├── runner.rs            # Event loop orchestrator
│   │   └── event.rs             # Event types
│   ├── agent/                   # Agent module
│   │   ├── mod.rs
│   │   ├── loader.rs            # Load agent.yaml
│   │   ├── executor.rs          # Execution logic
│   │   └── spec.rs              # Agent spec types
│   ├── services/                # Services module
│   │   ├── mod.rs
│   │   ├── session.rs
│   │   ├── memory.rs
│   │   ├── artifact.rs
│   │   └── backends/
│   │       ├── filesystem.rs
│   │       ├── postgres.rs
│   │       ├── redis.rs
│   │       └── s3.rs
│   ├── sandbox/                 # Sandbox module
│   │   ├── mod.rs
│   │   ├── trait.rs             # Sandbox trait
│   │   ├── bubblewrap.rs
│   │   └── docker.rs
│   ├── scheduler/               # Scheduler module
│   │   ├── mod.rs
│   │   ├── schedule.rs          # Schedule types
│   │   ├── service.rs           # Background service
│   │   ├── store.rs             # YAML persistence
│   │   └── run_log.rs           # JSONL run history
│   ├── llm/                     # LLM module
│   │   ├── mod.rs
│   │   ├── openrouter.rs
│   │   ├── openai.rs
│   │   ├── anthropic.rs
│   │   └── ollama.rs
│   └── tools/                   # Tools module
│       ├── mod.rs
│       ├── executor.rs          # Tool execution
│       ├── schedule.rs          # Schedule tools
│       ├── mcp.rs
│       └── builtin/
│           ├── claude_code.rs
│           ├── opencode.rs
│           └── notify.rs
├── gateways/                    # First-party gateway plugins
│   ├── telegram/
│   │   ├── Cargo.toml
│   │   └── src/main.rs
│   └── discord/
│       ├── Cargo.toml
│       └── src/main.rs
├── examples/
│   ├── agents/                  # Example agents
│   └── docker-compose.yml       # Example deployment
├── docs/
│   ├── specs/                   # Design documents
│   └── examples/                # Example skills
├── Dockerfile
├── Cargo.toml
├── Cargo.lock
├── LICENSE                      # MIT
└── README.md
```

## 13. Configuration Reference

### Environment Variable Interpolation

Configuration files support shell-style environment variable expansion:

| Syntax | Behavior |
|--------|----------|
| `${VAR}` | Required - errors if not set |
| `${VAR:-default}` | Optional - uses default if not set |
| `${VAR:-}` | Optional - empty string if not set |
| `$$` | Escaped `$` (only needed before `{`) |

**Limitations:**
- No nested expansion: `${VAR:-${OTHER}}` is not supported
- Unclosed `${` (missing `}`) returns an error

### duragent.yaml (Current Implementation)

```yaml
# =============================================================================
# Workspace
# =============================================================================
# workspace: .duragent                     # Default: .duragent (relative to config file)
# All paths below default to subdirectories of the workspace when not set.

# =============================================================================
# Server Configuration
# =============================================================================
server:
  host: 0.0.0.0                        # Default: 0.0.0.0
  port: 8080                           # Default: 8080
  request_timeout_seconds: 300         # Default: 300 (5 min)
  idle_timeout_seconds: 60             # Default: 60
  keep_alive_interval_seconds: 15      # Default: 15
  admin_token: ${ADMIN_TOKEN:-}        # Optional, env var recommended

# =============================================================================
# Agent Directory (optional, defaults to {workspace}/agents)
# =============================================================================
# agents_dir: .duragent/agents

# =============================================================================
# Services
# =============================================================================
services:
  session:
    # path: .duragent/sessions             # Optional, defaults to {workspace}/sessions

# =============================================================================
# World Memory
# =============================================================================
world_memory:
  # path: .duragent/memory/world           # Optional, defaults to {workspace}/memory/world

# =============================================================================
# Scheduler (automatic, no configuration needed)
# =============================================================================
# Schedules are stored in {workspace}/schedules/ (sibling to sessions directory)
# Run logs are stored in {workspace}/schedules/runs/
# The scheduler starts automatically when the server starts.

# =============================================================================
# Gateways
# =============================================================================
gateways:
  # Built-in Telegram gateway
  telegram:
    enabled: true                      # Default: true
    bot_token: ${TELEGRAM_BOT_TOKEN}   # Required (use env var!)

  # External gateways (subprocess plugins)
  external:
    - name: discord
      command: /usr/local/bin/duragent-discord
      args: ["--verbose"]
      env:
        DISCORD_TOKEN: ${DISCORD_TOKEN}
      restart: on_failure              # always | on_failure | never

    - name: custom-gateway
      command: ./my-gateway            # Relative to config file directory
      restart: always

# =============================================================================
# Routes (Global Routing Rules)
# =============================================================================
# All gateway routing is configured here (not per-gateway).
# Rules are evaluated in order; first match wins.
# If no rules match, messages are dropped with a warning.
routes:
  # Route specific Telegram user to VIP agent
  - match:
      gateway: telegram
      sender_id: "123456789"
    agent: vip-assistant

  # Route specific Telegram group to dedicated agent
  - match:
      gateway: telegram
      chat_id: "-1001234567890"
    agent: group-assistant

  # Route all Telegram group chats to moderator
  - match:
      gateway: telegram
      chat_type: group
    agent: group-moderator

  # Discord DMs to personal assistant
  - match:
      gateway: discord
      chat_type: dm
    agent: personal-assistant

  # Specific Discord server to dedicated bot
  - match:
      gateway: discord
      chat_id: "server-123"
    agent: server-bot

  # Catch-all for any gateway (empty match = matches everything)
  - match: {}
    agent: default-assistant

# =============================================================================
# Sandbox
# =============================================================================
sandbox:
  mode: trust                          # trust | bubblewrap | docker
```

### Configuration Fields Reference

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `workspace` | path? | `.duragent` | Workspace root; other paths default to subdirectories of this |
| `server.host` | string | `0.0.0.0` | Bind address |
| `server.port` | u16 | `8080` | HTTP port |
| `server.request_timeout_seconds` | u64 | `300` | Non-streaming request timeout |
| `server.idle_timeout_seconds` | u64 | `60` | SSE idle timeout |
| `server.keep_alive_interval_seconds` | u64 | `15` | SSE keep-alive interval |
| `server.admin_token` | string? | none | Admin API token (localhost-only if unset) |
| `agents_dir` | path? | `{workspace}/agents` | Agent definitions directory |
| `services.session.path` | path? | `{workspace}/sessions` | Session storage directory |
| `world_memory.path` | path? | `{workspace}/memory/world` | Shared world memory directory |
| `gateways.telegram.enabled` | bool | `true` | Enable Telegram gateway |
| `gateways.telegram.bot_token` | string | required | Telegram bot token |
| `gateways.external[].name` | string | required | Gateway identifier |
| `gateways.external[].command` | string | required | Path to gateway binary |
| `gateways.external[].args` | array | `[]` | Command arguments |
| `gateways.external[].env` | map | `{}` | Environment variables |
| `gateways.external[].restart` | enum | `on_failure` | Restart policy |
| `routes[]` | array | `[]` | Global routing rules |
| `routes[].match` | object | `{}` | Match conditions (all must match) |
| `routes[].agent` | string | required | Agent to route to |
| `sandbox.mode` | string | `trust` | Sandbox mode: trust, bubblewrap, docker |

**Path Resolution:** All relative paths are resolved relative to the config file directory, not the current working directory. When optional path fields (`agents_dir`, `services.session.path`, `world_memory.path`) are omitted, they default to subdirectories of the workspace (which itself defaults to `.duragent`). A workspace directives directory (`{workspace}/directives/`) is also derived automatically.

### Routing Match Conditions

| Field | Description | Example |
|-------|-------------|---------|
| `gateway` | Gateway name to match | `telegram`, `discord` |
| `chat_type` | Conversation type | `dm`, `group`, `channel` |
| `chat_id` | Specific chat ID | `-1001234567890` |
| `sender_id` | Specific user ID | `123456789` |

All conditions in a rule must match (AND logic). Rules are evaluated top-to-bottom; first match wins. If no rules match, messages are dropped with a warning. Use an empty `match: {}` as a catch-all rule.

### agent.yaml (Complete Example)

```yaml
apiVersion: duragent/v1alpha1
kind: Agent
metadata:
  name: my-assistant
  description: Personal productivity assistant
  version: 1.0.0
  labels:
    domain: productivity

spec:
  model:
    provider: openrouter
    name: anthropic/claude-sonnet-4
    temperature: 0.7
    max_output_tokens: 4096

  soul: ./SOUL.md                     # agent personality (optional)
  system_prompt: ./SYSTEM_PROMPT.md    # system prompt (optional)
  instructions: ./INSTRUCTIONS.md      # runtime instructions (optional)

  # Session behavior
  session:
    on_disconnect: continue            # or: pause (default)
    max_tool_iterations: 10            # default: 10
    # max_background_runtime: 30m      # planned
    # task_list: my-project            # planned

  # Memory
  memory:
    enabled: true                      # Enables memory tool for this agent

  # Tools
  tools:
    - type: builtin
      name: bash
    - type: cli
      name: code-search
      command: ./tools/code-search.sh
      description: Search codebase for patterns
    - type: mcp
      name: github
      server: /usr/local/bin/github-mcp

  # Skills (planned)
  # skills_dir: ./skills/
  # skills:
  #   - path: ../shared-skills/meeting-notes/

  # Triggers (planned)
  # triggers:
  #   - pattern: "extract tasks from *"
  #     skill: task-extraction
  #   - schedule: "0 20 * * FRI"
  #     skill: weekly-review
```
