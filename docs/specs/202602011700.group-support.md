# Access Control & Group Support

**Status:** Phase 2 Complete

## Overview

Add layered access control for DMs and groups, with mention gating, message queuing, and per-sender policies. Enables agents to:
- Control who can interact (access policies)
- Scale in high-traffic groups (mention gating)
- Handle rapid messages gracefully (queue modes)
- Apply different rules per user (per-sender policies)

### Problems Addressed

| Problem | Solution |
|---------|----------|
| Anyone can DM and spam the bot | DM access policies (pairing, allowlist) |
| Agent responds to every group message | Mention gating (default: require @mention) |
| Messages arrive while agent is processing | Queue modes (collect, interrupt, followup) |
| Different users need different permissions | Per-sender tool policies |
| No context when mentioned in group | Silent listening + context buffer |

## Architecture

Messages flow through 5 independent, composable layers:

1. **Routing** — Which agent handles this? (existing rules)
2. **Access Control** — Is this sender allowed? (DM/group policies, allowlists)
3. **Mention Gating** — Did they trigger a response? (groups only: @mention, reply, command prefix)
4. **Queue Handler** — How to handle if agent is busy? (collect, interrupt, followup, drop)
5. **Tool Policy** — What can this sender do? (per-sender tool restrictions)

Each layer can reject or modify the message before it reaches the LLM.

## Access Policies

### DM Policies

Control who can send direct messages to the agent.

| Policy | Behavior | Use Case |
|--------|----------|----------|
| `disabled` | Reject all DMs | Group-only bot |
| `allowlist` | Only listed user IDs | Private bot, known users |
| `open` | Accept all DMs | Public bot (dangerous for cost) |
| `pairing` | Require owner approval flow | Controlled access with discoverability |

### DM Pairing Flow

When `policy: pairing`, unknown users must be approved:

1. Unknown user sends DM
2. Bot replies: "DM access requires approval. Your request has been sent to the owner."
3. Owner receives approval request via configured notification channel
4. Owner runs `/approve <user_id>` or `/deny <user_id>`
5. Approved users are added to an auto-populated allowlist and can DM freely going forward

Pairing state (pending requests + approved users) is stored as YAML in `{workspace}/access/pairing/`.

### Group Policies

Control which groups the agent participates in.

| Policy | Behavior | Use Case |
|--------|----------|----------|
| `disabled` | Ignore all group messages | DM-only bot |
| `allowlist` | Only listed group IDs | Controlled deployment |
| `open` | Participate in any group | Public bot |

Allowlists support wildcards (e.g. `telegram:*` for all Telegram groups).

## Group Configuration

### Mention Gating

Groups use mention gating by default — agent only responds when triggered.

| Mode | Behavior | LLM Calls |
|------|----------|-----------|
| `mention` (default) | Only respond when @mentioned, replied to, or command prefix used | On trigger only |
| `always` | Respond to every message | Every message |

Mention detection supports:
- Explicit `@bot_username` in message text
- Reply to bot's previous message
- Command prefixes (e.g. `/ask`, `!help`)

### Silent Context Collection

When not mentioned, group messages are stored locally as JSONL (no LLM call). When the agent *is* mentioned, recent context is injected into the prompt so it understands the conversation.

Buffer is configurable: rolling size (`max_messages`, default 100) and expiry (`max_age_hours`, default 24).

### Per-Group Overrides

Each group can override defaults for activation mode, context buffer size, and tool policies. Groups are identified by `{gateway}:{group_id}` with wildcard support.

## Per-Sender Tool Policies

Within groups, different users can have different tool permissions (e.g. admins can run bash, members cannot).

**Resolution order:**
1. Exact sender ID match
2. Wildcard pattern match (e.g. `admin_*`)
3. Group default tool policy
4. Agent default tool policy

## Queue Handling

When messages arrive while the agent is processing:

| Mode | Behavior | Use Case |
|------|----------|----------|
| `collect` (default) | Wait for a time window, batch all messages into one request | Rapid message senders |
| `interrupt` | Cancel current processing, restart with new message | Time-sensitive, latest matters |
| `followup` | Complete current, then process queued as follow-up | Preserve all context |
| `drop` | Ignore messages while processing | Simple, predictable |

**Overflow handling** when queue exceeds `max_pending`: `drop_old`, `drop_new`, or `reject` (with optional custom message).

## Message Debouncing

Separate from queue handling — debouncing batches rapid messages *before* they enter the queue (e.g. user sends 3 messages in 2 seconds, they get combined into one). Scoped per sender or per conversation.

| Aspect | Debounce | Queue |
|--------|----------|-------|
| When | Before processing starts | While processing |
| Purpose | Batch rapid typing | Handle concurrent messages |

## Owner Controls

Group owners (and optionally admins) can adjust settings at runtime via commands:

- `/activation mention|always|status` — change activation mode
- `/queue collect|interrupt|followup` — change queue mode
- `/access approve|deny|list` — manage DM pairing

Runtime changes are persisted per-group in workspace YAML files.

## Gateway Protocol Extension

Gateways must provide additional metadata on messages:
- `chat_type`: direct, group, or channel
- `mentions_bot`: whether bot was explicitly mentioned
- `reply_to_bot`: whether this is a reply to bot's message
- `sender_role`: owner, admin, or member
- `sender_id` / `sender_username`: for per-sender policies

## Implementation Phases

### Phase 1: Access Policies + Sender Attribution ✅

Delivered: agent-level access control and sender identity in group messages.

**Access policies** (`spec.access` in agent.yaml):
- DM policies: `open` (default), `disabled`, `allowlist` (by sender ID)
- Group policies: `open` (default), `disabled`, `allowlist` (by chat ID)
- Per-sender disposition within groups: `allow`, `passive`, `silent`, `block`
  - `allow` — LLM sees it, triggers response
  - `passive` — stored as UserMessage (LLM sees in future turns), no response triggered
  - `silent` — stored in events.jsonl for audit, excluded from LLM conversation
  - `block` — discarded entirely
  - Resolution: `sender_overrides` map → `sender_default`

**Sender attribution** for group messages:
- Content prefixed with sender label: `"Alice: hello world"`
- Label priority: `display_name > username > sender_id`
- `MessageHandler` trait updated to receive `&Sender`

**SilentMessage event** for `silent` disposition:
- Stored in `events.jsonl` for audit
- `to_message()` returns `None` — invisible to LLM

**Scope:** Gateway path only. HTTP API and CLI bypass access control (operator-level, unrestricted).

### Phase 2: Mention Gating + Context Buffer ✅

Delivered: activation modes, bot mention detection, context buffer with configurable mode, and context injection on trigger.

**Gateway protocol extension:**
- Added `mentions_bot` and `reply_to_bot` fields to `MessageReceivedData`
- Both default to `false` for backward compatibility
- Simplified `MessageHandler` trait to accept `&MessageReceivedData` directly

**Bot mention detection in gateways:**
- Discord: captures bot user ID from `Ready` event, checks `msg.mentions` and `msg.referenced_message`
- Telegram: fetches bot identity via `get_me()`, uses `msg.parse_entities()` with `MessageEntityRef` for safe UTF-16 → UTF-8 entity text extraction

**Activation modes** (`spec.access.groups.activation`):
- `mention` (default) — only respond when @mentioned or replied to
- `always` — respond to every allowed message

**Mention gating** in handler:
- In `mention` mode, non-triggered messages from `Allow` senders are routed to the context buffer instead of triggering a response
- Routing depends on `context_buffer.mode` (see below)

**Context buffer modes** (`spec.access.groups.context_buffer.mode`):
- `silent` (default) — ephemeral in-memory `VecDeque`, injected as a system block when bot is triggered, lost on crash
- `passive` — stored as `UserMessage` in conversation history (durable, but accumulates tokens)

**Context buffer injection:**
- On trigger, recent silent messages (filtered by `max_messages` and `max_age_hours`) are injected into the system prompt as a `group_context` block
- Skipped for `passive` mode (messages already in conversation history)
- Applied in both simple chat and agentic loop paths

**Configurable silent buffer cap:**
- `context_buffer.max_messages` flows from agent spec through `ActorConfig` to `SessionActor`
- `DEFAULT_SILENT_BUFFER_CAP` (200) used when agent spec is unavailable (HTTP API, scheduler, recovery)

**Buffer config:** `max_messages` (default 100), `max_age_hours` (default 24)

### Phase 3: Queue Handling + Debouncing
- Queue modes: `collect` (default), `interrupt`, `followup`, `drop`
- Overflow strategies: `drop_old`, `drop_new`, `reject`
- Message debouncing: batch rapid messages before queueing (per-sender or per-conversation)

### Phase 4: Advanced Features
- `pairing` DM policy (owner approval flow, persistent state)
- Per-sender tool policies (different tool permissions per user)
- Owner runtime commands (`/activation`, `/queue`, `/access`)
- Wildcard patterns in allowlists (e.g. `telegram:*`)
- Gateway protocol extension: `sender_role` (owner/admin/member)
- Formal role system (if needed)

## Cost Impact

- 1000 group messages/day with 5% mention rate → **50 LLM calls** (95% reduction)
- DM pairing → controlled access, predictable costs
- Context buffer storage: ~100KB/day (negligible)

## Open Questions

1. **Multi-agent groups**: Shared context buffer or separate per agent?
2. **Pairing expiry**: Should approved users expire after inactivity?
3. **Rate limiting**: Per-user rate limits even with mention-gating?
4. **Cross-platform identity**: Same user on Telegram and Discord — unified or separate?
