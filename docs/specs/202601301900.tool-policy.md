# Tool Policy — Command Filtering & Notifications

**Status:** Implemented

## Overview

A policy system to control which tools agents can execute, with human-in-the-loop approval and persistent permission storage. This provides safety guardrails while maintaining autonomous operation for approved commands.

## Features

- **Flexible modes**: Choose between dangerous (trust all), ask (human approval), or restrict (allowlist only)
- **Deny list air-gap**: Always-checked deny list blocks dangerous commands regardless of mode
- **Tool type prefixes**: Pattern format `tool_type:pattern` for bash, mcp, and builtin tools
- **Multiple notification deliveries**: Log and/or webhook notifications
- **Persistent permissions**: Approvals saved to `policy.local.yaml`
- **Sensible defaults**: Works without config files (backwards compatible)

## Configuration Structure

### File Layout

```
agents/my-agent/
  agent.yaml              # agent definition
  policy.yaml             # base policy (version controlled)
  policy.local.yaml       # user overrides (gitignored, auto-created)
```

### policy.yaml

```yaml
apiVersion: agnx/v1alpha1
kind: Policy

# Mode: "dangerous" | "ask" | "restrict"
#   - dangerous: trust all commands, only deny list blocks
#   - ask: prompt user for unknown commands, allow list auto-approves
#   - restrict: only allow list runs, everything else denied
mode: ask

# Patterns to deny (air-gap, ALWAYS checked first in ALL modes)
# Format: tool_type:pattern
deny:
  - "bash:rm -rf /*"
  - "bash:*sudo*"
  - "*:*password*"          # wildcard tool type matches all

# Patterns to allow
# Format: tool_type:pattern
allow:
  - "bash:cargo *"
  - "bash:git *"
  - "mcp:github:*"
  - "mcp:filesystem:read*"

# Notification settings
notify:
  enabled: true
  patterns:
    - "bash:git push*"
    - "bash:rm *"
  deliveries:
    - type: log
    - type: webhook
      url: https://hooks.slack.com/services/...
```

### policy.local.yaml (User Overrides)

```yaml
apiVersion: agnx/v1alpha1
kind: Policy

# User-approved patterns (merged with base)
allow:
  - "bash:npm install *"
  - "bash:cargo build *"

# Override mode if needed
mode: ask
```

## Policy Modes

| Mode | Deny List | Allow List | Unknown Commands |
|------|-----------|------------|------------------|
| `dangerous` | Blocks (air-gap) | Ignored | Allowed |
| `ask` | Blocks (air-gap) | Auto-approved | Requires human approval |
| `restrict` | Blocks (air-gap) | Allowed | Denied |

**Important:** The deny list is always checked first, regardless of mode. This provides an "air-gap" safety mechanism.

## Pattern Format

Patterns use the format `tool_type:pattern`:

| Pattern | Description |
|---------|-------------|
| `bash:cargo *` | Bash commands starting with "cargo" |
| `mcp:github:*` | Any tool from github MCP server |
| `mcp:*:read*` | Any MCP tool with "read" in name |
| `*:*secret*` | Block "secret" in any tool |
| `*password*` | Same as `*:*password*` (no colon = all tools) |

Patterns use glob-style matching where `*` matches any characters.

## Merge Behavior

When both `policy.yaml` and `policy.local.yaml` exist:

| Field | Merge Strategy |
|-------|----------------|
| `mode` | Local overrides base (if not `dangerous`) |
| `deny` | Lists merged (union) |
| `allow` | Lists merged (union) |
| `notify.enabled` | Either true = enabled |
| `notify.patterns` | Lists merged (union) |
| `notify.deliveries` | Lists merged (all deliveries called) |

## Default Behavior (No Policy Files)

When no policy files exist:

```yaml
# Implicit defaults
apiVersion: agnx/v1alpha1
kind: Policy
mode: dangerous     # no filtering, backwards compatible
deny: []
allow: []
notify:
  enabled: false
  patterns: []
  deliveries: []
```

This maintains backwards compatibility — existing agents work unchanged.

## User Approval Flow (mode: ask)

```
┌─────────────────────────────────────────────────────────────┐
│ Agent wants to run: npm install sqlite3                     │
│                                                             │
│ This command is not in your allowlist.                      │
│                                                             │
│ [y] Allow Once  [a] Allow Always  [n] Deny                  │
└─────────────────────────────────────────────────────────────┘

User selects "Allow Always"
     ↓
Agent updates policy.local.yaml:
     allow:
       - "bash:npm install sqlite3"
     ↓
Command executes
     ↓
Future matching commands auto-approved
```

### Approval Decisions

| Decision | Effect |
|----------|--------|
| `allow_once` | Execute once, ask again next time |
| `allow_always` | Execute and add pattern to `policy.local.yaml` |
| `deny` | Don't execute, inform the agent |

## Notification System

When `notify.enabled: true` and command matches `notify.patterns`:

1. Command executes (notifications don't block)
2. Notification sent to all configured deliveries
3. Event recorded in session

### Delivery Types

```yaml
notify:
  enabled: true
  patterns:
    - "bash:rm *"
  deliveries:
    # Log to tracing
    - type: log

    # Send to webhook URL
    - type: webhook
      url: https://hooks.slack.com/services/...
```

### Webhook Payload

```json
{
  "event": "command_notification",
  "session_id": "session_abc123",
  "agent": "my-agent",
  "command": "git push origin main",
  "success": true
}
```

## API Endpoints

### Approve Command

```
POST /api/v1/sessions/{session_id}/approve
```

Request:
```json
{
  "call_id": "call_abc123",
  "command": "npm install sqlite3",
  "decision": "allow_always"
}
```

Response (when agent completes):
```json
{
  "status": "complete",
  "message_id": "msg_abc123",
  "content": "I've installed sqlite3 successfully."
}
```

Response (when another tool needs approval):
```json
{
  "status": "pending_approval",
  "call_id": "call_xyz789",
  "command": "npm install express"
}
```

The response is polymorphic based on the `status` field:
- `complete`: Agent finished responding after the approved command
- `pending_approval`: Agent needs approval for another command before completing

## SSE Events

| Event | Description |
|-------|-------------|
| `approval_required` | Command needs user approval |
| `tool_result` | Normal tool execution result |

### approval_required Event

```json
{
  "call_id": "call_abc123",
  "command": "npm install sqlite3"
}
```

## Gateway Support

### Telegram Inline Keyboards

When approval is required, Telegram gateway can display inline buttons:

```
⚠️ Approval required for: npm install sqlite3

[✅ Allow Once] [✅ Allow Always] [❌ Deny]
```

User taps a button → callback query → approval processed.

## Implementation Files

| File | Description |
|------|-------------|
| `agent/policy.rs` | Policy types, loading, merging, pattern matching |
| `agent/mod.rs` | Export policy module |
| `agent/spec.rs` | Policy field in AgentSpec |
| `tools/error.rs` | ApprovalRequired, PolicyDenied errors |
| `tools/executor.rs` | Policy checking before execution |
| `tools/notify.rs` | Notification delivery |
| `session/events.rs` | Approval/notification events |
| `session/agentic.rs` | Handle ApprovalRequired in loop |
| `handlers/v1/sessions.rs` | Approve endpoint |
| `gateway/manager.rs` | Inline keyboard support |
| `agnx-gateway-protocol` | InlineKeyboard, CallbackQuery types |
| `agnx-gateway-telegram` | Telegram keyboard/callback handling |

## Future Enhancements (Planned)

- Time-limited approvals ("allow for 1 hour")
- Approval delegation (approve via separate admin API)
- Audit log of all approvals
- Policy inheritance (global → project → agent)
- More delivery types (email, file)
